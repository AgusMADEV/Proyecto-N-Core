# Reporte de proyecto

## Estructura del proyecto

```
C:\xampp\htdocs\GitHub\Proyecto-N-core
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ comparador.py
‚îú‚îÄ‚îÄ comparador_v3.py
‚îú‚îÄ‚îÄ datos_ejemplo
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ articulo1_procesamiento_paralelo.txt
‚îÇ   ‚îú‚îÄ‚îÄ articulo2_multicore.txt
‚îÇ   ‚îú‚îÄ‚îÄ articulo3_python.txt
‚îÇ   ‚îú‚îÄ‚îÄ articulo4_analisis_texto.txt
‚îÇ   ‚îî‚îÄ‚îÄ articulo5_optimizacion.txt
‚îú‚îÄ‚îÄ frontend
‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ styles.css
‚îú‚îÄ‚îÄ generador_imagenes.py
‚îú‚îÄ‚îÄ imagenes_entrada
‚îÇ   ‚îú‚îÄ‚îÄ imagen1_colores.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen2_gradiente.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen3_patron.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen4_rayas.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen5_texto.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen6_multicore.jpg
‚îÇ   ‚îî‚îÄ‚îÄ imagen7_compleja.png
‚îú‚îÄ‚îÄ imagenes_salida
‚îÇ   ‚îú‚îÄ‚îÄ imagen1_colores_v4.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen2_gradiente_v4.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen3_patron_v4.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen4_rayas_v4.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen5_texto_v4.jpg
‚îÇ   ‚îú‚îÄ‚îÄ imagen6_multicore_v4.jpg
‚îÇ   ‚îî‚îÄ‚îÄ imagen7_compleja_v4.png
‚îú‚îÄ‚îÄ paralelo.py
‚îú‚îÄ‚îÄ secuencial.py
‚îú‚îÄ‚îÄ servidor.py
‚îú‚îÄ‚îÄ version3_paralelo.py
‚îî‚îÄ‚îÄ version3_secuencial.py
```

## C√≥digo (intercalado)

# Proyecto-N-core
**README.md**
```markdown
# üöÄ Proyecto: Procesamiento Multin√∫cleo en Python

## üìã Descripci√≥n
Este proyecto demuestra el uso de **procesamiento multin√∫cleo** en Python para mejorar el rendimiento de aplicaciones que requieren c√°lculos intensivos.

## üéØ Objetivo
Demostrar c√≥mo un proceso puede dividirse en procesos paralelos que se ejecutan simult√°neamente en m√∫ltiples n√∫cleos, reduciendo significativamente el tiempo de procesamiento.

## üìÇ Estructura del Proyecto

### Versi√≥n 1: Procesamiento de N√∫meros
- `version1_secuencial.py` - Procesamiento secuencial de n√∫meros (sin paralelismo)
- `version1_paralelo.py` - Procesamiento de n√∫meros con multiprocessing
- `comparador.py` - Compara el rendimiento de ambos enfoques

### Versi√≥n 2: Procesamiento de Archivos
- `version2_secuencial.py` - Lectura y an√°lisis de archivos secuencial
- `version2_paralelo.py` - Lectura y an√°lisis de archivos en paralelo
- `comparador_v2.py` - Compara rendimiento de procesamiento de archivos
- `datos_ejemplo/` - Carpeta con archivos de texto de ejemplo para procesar

### Versi√≥n 3: Procesamiento de Im√°genes (ACTUAL) ‚ú®
- `version3_secuencial.py` - Procesamiento secuencial de im√°genes con filtros
- `version3_paralelo.py` - Procesamiento paralelo de im√°genes
- `comparador_v3.py` - Compara rendimiento de procesamiento de im√°genes
- `generador_imagenes.py` - Genera im√°genes de ejemplo para pruebas
- `imagenes_entrada/` - Carpeta con im√°genes para procesar
- `imagenes_salida/` - Carpeta con im√°genes procesadas

### Versi√≥n 4: Interfaz Gr√°fica Web (ACTUAL) ‚ú®
- `servidor.py` - Backend WebSocket as√≠ncrono (asyncio)
- `frontend/index.html` - Dashboard web en tiempo real
- `frontend/app.js` - L√≥gica del cliente WebSocket
- `frontend/styles.css` - Tema oscuro del dashboard

### Versiones Futuras
- Versi√≥n 5: Optimizaciones avanzadas (cach√©, colas con prioridad)

## üîß Requisitos
- Python 3.8 o superior
- Biblioteca est√°ndar (no requiere instalaciones adicionales para V1 y V2)
- **Pillow** (requerido para Versiones 3 y 4):
  ```powershell
  pip install Pillow
  ```
- **websockets + psutil** (requerido para Versi√≥n 4):
  ```powershell
  pip install websockets psutil
  ```

## üöÄ Uso

### Versi√≥n 1: Procesamiento de N√∫meros

#### Ejecutar procesamiento secuencial
```powershell
python version1_secuencial.py
```

#### Ejecutar procesamiento paralelo
```powershell
python version1_paralelo.py
```

#### Comparar rendimiento
```powershell
python comparador.py
```

### Versi√≥n 2: Procesamiento de Archivos ‚ú®

#### Ejecutar an√°lisis secuencial de archivos
```powershell
python version2_secuencial.py
```

#### Ejecutar an√°lisis paralelo de archivos
```powershell
python version2_paralelo.py
```

#### Comparar rendimiento de versi√≥n 2
```powershell
python comparador_v2.py
```

**Nota:** Los scripts buscan archivos `.txt` en la carpeta `datos_ejemplo/`. La carpeta ya incluye 5 archivos de ejemplo para probar.

### Versi√≥n 3: Procesamiento de Im√°genes ‚ú®

#### Generar im√°genes de ejemplo
```powershell
python generador_imagenes.py
```

#### Ejecutar procesamiento secuencial de im√°genes
```powershell
python version3_secuencial.py
```

#### Ejecutar procesamiento paralelo de im√°genes
```powershell
python version3_paralelo.py
```

#### Comparar rendimiento de versi√≥n 3
```powershell
python comparador_v3.py
```

**Nota:** Puedes generar im√°genes de prueba con `generador_imagenes.py` o usar tus propias im√°genes en la carpeta `imagenes_entrada/`.

### Versi√≥n 4: Interfaz Gr√°fica Web ‚ú®

#### Paso 1 ‚Äî Instalar dependencias
```powershell
pip install websockets psutil Pillow
```

#### Paso 2 ‚Äî Iniciar el servidor
```powershell
python servidor.py
```

#### Paso 3 ‚Äî Abrir el dashboard
Abre el archivo `frontend/index.html` en tu navegador.

**Caracter√≠sticas del dashboard:**
- üìä Monitorizaci√≥n en tiempo real de CPU por n√∫cleo
- üìà M√©tricas: Speedup, Eficiencia, Tiempo total
- ‚ñ∂ Control de procesamiento (Iniciar / Detener)
- ‚öôÔ∏è Configuraci√≥n de workers y operaciones
- üìã Consola de logs en vivo
- üñºÔ∏è Resultados por imagen con tiempos

## üìä Conceptos Aplicados

### Versi√≥n 1
- ‚úÖ Procesos paralelos
- ‚úÖ Uso de m√≥dulo `multiprocessing`
- ‚úÖ Distribuci√≥n de carga entre n√∫cleos
- ‚úÖ Medici√≥n de rendimiento
- ‚úÖ Sincronizaci√≥n de resultados

### Versi√≥n 2
- ‚úÖ Lectura de m√∫ltiples archivos en paralelo
- ‚úÖ An√°lisis de texto y estad√≠sticas
- ‚úÖ Conteo de palabras, l√≠neas y caracteres
- ‚úÖ Identificaci√≥n de palabras frecuentes
- ‚úÖ Expresiones regulares para procesamiento de texto
- ‚úÖ Manejo eficiente de archivos grandes
- ‚úÖ Pool de procesos para I/O intensivo

### Versi√≥n 3
- ‚úÖ Procesamiento paralelo de im√°genes
- ‚úÖ Aplicaci√≥n de filtros (blur, escala de grises, sharpen)
- ‚úÖ Redimensionamiento en batch
- ‚úÖ Uso de Pillow (PIL) para manipulaci√≥n de im√°genes
- ‚úÖ Procesamiento CPU-intensivo optimizado
- ‚úÖ M√∫ltiples formatos de imagen soportados
- ‚úÖ Generaci√≥n autom√°tica de im√°genes de prueba

### Versi√≥n 4
- ‚úÖ Servidor WebSocket as√≠ncrono con `asyncio`
- ‚úÖ Dashboard web en tiempo real
- ‚úÖ Monitorizaci√≥n de CPU por n√∫cleo con `psutil`
- ‚úÖ Control interactivo (start / stop)
- ‚úÖ Logs en vivo en consola web
- ‚úÖ M√©tricas en tiempo real (speedup, eficiencia)
- ‚úÖ Integraci√≥n `ProcessPoolExecutor` + `asyncio`
- ‚úÖ Broadcasting a m√∫ltiples clientes conectados

## üéì Basado en
- Apuntes de Programaci√≥n Multiproceso
- Ejercicios de clase de procesamiento paralelo
- Proyecto de referencia: Sistema de Procesamiento de Im√°genes

---
**Autor:** AgusMAdev
```
**comparador.py**
```python
"""
COMPARADOR VERSI√ìN 2 - PROCESAMIENTO DE ARCHIVOS
================================================
Este script compara el rendimiento entre el procesamiento SECUENCIAL
y PARALELO de archivos de texto.

Permite visualizar claramente las ventajas del multin√∫cleo.
"""

import time
import multiprocessing
from datetime import datetime
from pathlib import Path
import os


# Importar funciones de ambas versiones
from secuencial import analizar_archivo as analizar_secuencial
from paralelo import analizar_archivo as analizar_paralelo


def ejecutar_prueba_secuencial(archivos):
    """
    Ejecuta el procesamiento secuencial de archivos.
    
    Args:
        archivos: Lista de rutas de archivos
    
    Returns:
        Tupla (resultados, tiempo_total)
    """
    print("\n" + "="*70)
    print("üêå EJECUTANDO VERSI√ìN SECUENCIAL")
    print("="*70)
    print(f"üìä Archivos: {len(archivos)}")
    print(f"üñ•Ô∏è  Modo: UN SOLO N√öCLEO")
    print("="*70 + "\n")
    
    inicio = time.time()
    resultados = []
    
    for i, archivo in enumerate(archivos, 1):
        print(f"üîÑ Procesando {i}/{len(archivos)}: {os.path.basename(archivo)}")
        resultado = analizar_secuencial(archivo)
        resultados.append(resultado)
        
        if resultado['exito']:
            print(f"  ‚úÖ {resultado['num_palabras']} palabras | "
                  f"{resultado['num_lineas']} l√≠neas | {resultado['tiempo_proceso']:.3f}s\n")
    
    tiempo_total = time.time() - inicio
    
    return resultados, tiempo_total


def ejecutar_prueba_paralelo(archivos, num_procesos=None):
    """
    Ejecuta el procesamiento paralelo de archivos.
    
    Args:
        archivos: Lista de rutas de archivos
        num_procesos: N√∫mero de procesos (None = todos los n√∫cleos)
    
    Returns:
        Tupla (resultados, tiempo_total)
    """
    if num_procesos is None:
        num_procesos = multiprocessing.cpu_count()
    
    print("\n" + "="*70)
    print("üöÄ EJECUTANDO VERSI√ìN PARALELA")
    print("="*70)
    print(f"üìä Archivos: {len(archivos)}")
    print(f"üñ•Ô∏è  N√∫cleos disponibles: {multiprocessing.cpu_count()}")
    print(f"‚öôÔ∏è  Procesos a usar: {num_procesos}")
    print("="*70 + "\n")
    
    inicio = time.time()
    
    with multiprocessing.Pool(processes=num_procesos) as pool:
        resultados = pool.map(analizar_paralelo, archivos)
    
    tiempo_total = time.time() - inicio
    
    return resultados, tiempo_total


def calcular_metricas(tiempo_secuencial, tiempo_paralelo, num_procesos):
    """
    Calcula m√©tricas de rendimiento comparativo.
    
    Args:
        tiempo_secuencial: Tiempo de ejecuci√≥n secuencial
        tiempo_paralelo: Tiempo de ejecuci√≥n paralela
        num_procesos: N√∫mero de procesos utilizados
    
    Returns:
        Diccionario con las m√©tricas
    """
    speedup = tiempo_secuencial / tiempo_paralelo
    eficiencia = (speedup / num_procesos) * 100
    reduccion_tiempo = ((tiempo_secuencial - tiempo_paralelo) / tiempo_secuencial) * 100
    
    return {
        'speedup': speedup,
        'eficiencia': eficiencia,
        'reduccion_tiempo': reduccion_tiempo
    }


def mostrar_comparacion(tiempo_sec, tiempo_par, metricas, archivos_sec, archivos_par):
    """
    Muestra una comparaci√≥n visual de los resultados.
    """
    print("\n" + "="*70)
    print("üìä COMPARACI√ìN DE RENDIMIENTO")
    print("="*70)
    
    # Informaci√≥n de archivos procesados
    exitos_sec = sum(1 for r in archivos_sec if r['exito'])
    exitos_par = sum(1 for r in archivos_par if r['exito'])
    
    print(f"\n‚úÖ Archivos procesados correctamente:")
    print(f"   Secuencial: {exitos_sec}/{len(archivos_sec)}")
    print(f"   Paralelo:   {exitos_par}/{len(archivos_par)}")
    
    # Estad√≠sticas totales
    if exitos_sec > 0:
        total_palabras_sec = sum(r['num_palabras'] for r in archivos_sec if r['exito'])
        total_lineas_sec = sum(r['num_lineas'] for r in archivos_sec if r['exito'])
        
        print(f"\nüìù Total de palabras procesadas: {total_palabras_sec:,}")
        print(f"üìÑ Total de l√≠neas procesadas: {total_lineas_sec:,}")
    
    # Tiempos
    print(f"\n‚è±Ô∏è  TIEMPOS DE EJECUCI√ìN:")
    print(f"   Secuencial:  {tiempo_sec:.2f} segundos")
    print(f"   Paralelo:    {tiempo_par:.2f} segundos")
    
    # M√©tricas
    print(f"\nüöÄ M√âTRICAS DE RENDIMIENTO:")
    print(f"   Speedup:     {metricas['speedup']:.2f}x m√°s r√°pido")
    print(f"   Eficiencia:  {metricas['eficiencia']:.1f}%")
    print(f"   Reducci√≥n:   {metricas['reduccion_tiempo']:.1f}% menos tiempo")
    
    # Visualizaci√≥n
    print(f"\nüìà VISUALIZACI√ìN:")
    barra_sec = "‚ñà" * int(tiempo_sec * 2)
    barra_par = "‚ñà" * int(tiempo_par * 2)
    
    print(f"   Secuencial: {barra_sec} {tiempo_sec:.2f}s")
    print(f"   Paralelo:   {barra_par} {tiempo_par:.2f}s")
    
    # Interpretaci√≥n
    print(f"\nüí° INTERPRETACI√ìN:")
    if metricas['speedup'] >= 3:
        print(f"   ‚ú® Excelente mejora de rendimiento!")
    elif metricas['speedup'] >= 2:
        print(f"   üëç Buena mejora de rendimiento")
    elif metricas['speedup'] >= 1.5:
        print(f"   ‚úì Mejora moderada de rendimiento")
    else:
        print(f"   ‚ö†Ô∏è  Mejora limitada (posible overhead o archivos peque√±os)")
    
    print("="*70 + "\n")


def main():
    """
    Funci√≥n principal del comparador.
    """
    print("\n" + "="*70)
    print("üî¨ COMPARADOR DE RENDIMIENTO - PROCESAMIENTO DE ARCHIVOS")
    print("="*70)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üñ•Ô∏è  Sistema: {multiprocessing.cpu_count()} n√∫cleos detectados")
    print("="*70)
    
    # Buscar archivos
    carpeta_datos = Path(__file__).parent / "datos_ejemplo"
    
    if not carpeta_datos.exists():
        print(f"\n‚ùå Error: La carpeta 'datos_ejemplo' no existe.")
        print("Por favor, ejecuta primero secuencial.py o paralelo.py")
        return
    
    archivos_txt = list(carpeta_datos.glob("*.txt"))
    
    if not archivos_txt:
        print(f"\n‚ùå Error: No se encontraron archivos .txt en '{carpeta_datos}'")
        return
    
    archivos_txt = [str(archivo) for archivo in archivos_txt]
    
    print(f"\nüìÇ Archivos encontrados: {len(archivos_txt)}")
    for archivo in archivos_txt:
        tamanio_kb = os.path.getsize(archivo) / 1024
        print(f"   - {os.path.basename(archivo)} ({tamanio_kb:.2f} KB)")
    
    # Ejecutar pruebas
    print("\n" + "="*70)
    print("üèÉ INICIANDO PRUEBAS COMPARATIVAS")
    print("="*70)
    
    # Prueba secuencial
    resultados_sec, tiempo_sec = ejecutar_prueba_secuencial(archivos_txt)
    
    # Peque√±a pausa entre pruebas
    time.sleep(1)
    
    # Prueba paralela
    num_procesos = multiprocessing.cpu_count()
    resultados_par, tiempo_par = ejecutar_prueba_paralelo(archivos_txt, num_procesos)
    
    # Calcular m√©tricas
    metricas = calcular_metricas(tiempo_sec, tiempo_par, num_procesos)
    
    # Mostrar comparaci√≥n
    mostrar_comparacion(tiempo_sec, tiempo_par, metricas, resultados_sec, resultados_par)
    
    # Guardar resultados
    print("üíæ Los resultados se han mostrado en consola")
    print("\n" + "="*70)
    print("‚úÖ COMPARACI√ìN COMPLETADA")
    print("="*70 + "\n")


if __name__ == "__main__":
    main()

```
**comparador_v3.py**
```python
"""
COMPARADOR VERSI√ìN 3 - PROCESAMIENTO DE IM√ÅGENES
=================================================
Este script compara el rendimiento entre el procesamiento SECUENCIAL
y PARALELO de im√°genes con filtros y transformaciones.

Permite visualizar claramente las ventajas del multin√∫cleo en procesamiento de im√°genes.
"""

import time
import multiprocessing
from datetime import datetime
from pathlib import Path
import os
import sys


def verificar_pillow():
    """
    Verifica que Pillow est√© instalado.
    """
    try:
        import PIL
        return True
    except ImportError:
        print("\n‚ùå ERROR: La biblioteca Pillow no est√° instalada.")
        print("\nüì¶ Para instalar Pillow, ejecuta:")
        print("   pip install Pillow")
        return False


# Importar funciones de ambas versiones
try:
    from version3_secuencial import procesar_imagen as procesar_secuencial
    from version3_paralelo import procesar_imagen_wrapper, procesar_imagen as procesar_paralelo
except ImportError as e:
    print(f"\n‚ùå Error al importar m√≥dulos: {e}")
    print("Aseg√∫rate de que version3_secuencial.py y version3_paralelo.py est√©n en la misma carpeta.")
    sys.exit(1)


def ejecutar_prueba_secuencial(imagenes, carpeta_salida_sec, operaciones):
    """
    Ejecuta el procesamiento secuencial de im√°genes.
    
    Args:
        imagenes: Lista de rutas de im√°genes
        carpeta_salida_sec: Carpeta donde guardar resultados secuenciales
        operaciones: Lista de operaciones a aplicar
    
    Returns:
        Tupla (resultados, tiempo_total)
    """
    print("\n" + "="*70)
    print("üêå EJECUTANDO VERSI√ìN SECUENCIAL")
    print("="*70)
    print(f"üìä Im√°genes: {len(imagenes)}")
    print(f"üñ•Ô∏è  Modo: UN SOLO N√öCLEO")
    print(f"üé® Operaciones: {', '.join([op['tipo'] for op in operaciones])}")
    print("="*70 + "\n")
    
    inicio = time.time()
    resultados = []
    
    for i, ruta_imagen in enumerate(imagenes, 1):
        nombre_archivo = os.path.basename(ruta_imagen)
        print(f"üîÑ Procesando {i}/{len(imagenes)}: {nombre_archivo}")
        
        # Generar ruta de salida
        nombre_sin_ext = os.path.splitext(nombre_archivo)[0]
        extension = os.path.splitext(nombre_archivo)[1]
        nombre_salida = f"{nombre_sin_ext}_sec{extension}"
        ruta_salida = os.path.join(carpeta_salida_sec, nombre_salida)
        
        resultado = procesar_secuencial(ruta_imagen, ruta_salida, operaciones)
        resultados.append(resultado)
        
        if resultado['exito']:
            print(f"  ‚úÖ {resultado['tamanio_original']} ‚Üí {resultado['tamanio_final']} | "
                  f"{resultado['tiempo_proceso']:.3f}s\n")
    
    tiempo_total = time.time() - inicio
    
    return resultados, tiempo_total


def ejecutar_prueba_paralelo(imagenes, carpeta_salida_par, operaciones, num_procesos=None):
    """
    Ejecuta el procesamiento paralelo de im√°genes.
    
    Args:
        imagenes: Lista de rutas de im√°genes
        carpeta_salida_par: Carpeta donde guardar resultados paralelos
        operaciones: Lista de operaciones a aplicar
        num_procesos: N√∫mero de procesos (None = todos los n√∫cleos)
    
    Returns:
        Tupla (resultados, tiempo_total)
    """
    if num_procesos is None:
        num_procesos = multiprocessing.cpu_count()
    
    print("\n" + "="*70)
    print("üöÄ EJECUTANDO VERSI√ìN PARALELA")
    print("="*70)
    print(f"üìä Im√°genes: {len(imagenes)}")
    print(f"üñ•Ô∏è  N√∫cleos disponibles: {multiprocessing.cpu_count()}")
    print(f"‚öôÔ∏è  Procesos a usar: {num_procesos}")
    print(f"üé® Operaciones: {', '.join([op['tipo'] for op in operaciones])}")
    print("="*70 + "\n")
    
    inicio = time.time()
    
    # Preparar argumentos
    tareas = []
    for ruta_imagen in imagenes:
        nombre_archivo = os.path.basename(ruta_imagen)
        nombre_sin_ext = os.path.splitext(nombre_archivo)[0]
        extension = os.path.splitext(nombre_archivo)[1]
        nombre_salida = f"{nombre_sin_ext}_par{extension}"
        ruta_salida = os.path.join(carpeta_salida_par, nombre_salida)
        
        tareas.append((ruta_imagen, ruta_salida, operaciones))
    
    # Procesar en paralelo
    with multiprocessing.Pool(processes=num_procesos) as pool:
        resultados = pool.map(procesar_imagen_wrapper, tareas)
    
    tiempo_total = time.time() - inicio
    
    return resultados, tiempo_total


def calcular_metricas(tiempo_secuencial, tiempo_paralelo, num_procesos):
    """
    Calcula m√©tricas de rendimiento comparativo.
    
    Args:
        tiempo_secuencial: Tiempo de ejecuci√≥n secuencial
        tiempo_paralelo: Tiempo de ejecuci√≥n paralela
        num_procesos: N√∫mero de procesos utilizados
    
    Returns:
        Diccionario con las m√©tricas
    """
    speedup = tiempo_secuencial / tiempo_paralelo
    eficiencia = (speedup / num_procesos) * 100
    reduccion_tiempo = ((tiempo_secuencial - tiempo_paralelo) / tiempo_secuencial) * 100
    
    return {
        'speedup': speedup,
        'eficiencia': eficiencia,
        'reduccion_tiempo': reduccion_tiempo
    }


def mostrar_comparacion(tiempo_sec, tiempo_par, metricas, imagenes_sec, imagenes_par):
    """
    Muestra una comparaci√≥n visual de los resultados.
    """
    print("\n" + "="*70)
    print("üìä COMPARACI√ìN DE RENDIMIENTO")
    print("="*70)
    
    # Informaci√≥n de im√°genes procesadas
    exitos_sec = sum(1 for r in imagenes_sec if r['exito'])
    exitos_par = sum(1 for r in imagenes_par if r['exito'])
    
    print(f"\n‚úÖ Im√°genes procesadas correctamente:")
    print(f"   Secuencial: {exitos_sec}/{len(imagenes_sec)}")
    print(f"   Paralelo:   {exitos_par}/{len(imagenes_par)}")
    
    # Estad√≠sticas totales
    if exitos_sec > 0:
        total_ops_sec = sum(r['num_operaciones'] for r in imagenes_sec if r['exito'])
        total_kb_entrada = sum(r['tamanio_kb_entrada'] for r in imagenes_sec if r['exito'])
        total_kb_salida_sec = sum(r['tamanio_kb_salida'] for r in imagenes_sec if r['exito'])
        
        print(f"\nüé® Total de operaciones realizadas: {total_ops_sec}")
        print(f"üíæ Total de datos procesados: {total_kb_entrada:.2f} KB")
        print(f"üíæ Total de datos generados: {total_kb_salida_sec:.2f} KB")
    
    # Tiempos
    print(f"\n‚è±Ô∏è  TIEMPOS DE EJECUCI√ìN:")
    print(f"   Secuencial:  {tiempo_sec:.2f} segundos")
    print(f"   Paralelo:    {tiempo_par:.2f} segundos")
    
    # M√©tricas
    print(f"\nüöÄ M√âTRICAS DE RENDIMIENTO:")
    print(f"   Speedup:     {metricas['speedup']:.2f}x m√°s r√°pido")
    print(f"   Eficiencia:  {metricas['eficiencia']:.1f}%")
    print(f"   Reducci√≥n:   {metricas['reduccion_tiempo']:.1f}% menos tiempo")
    
    # Visualizaci√≥n
    print(f"\nüìà VISUALIZACI√ìN:")
    max_tiempo = max(tiempo_sec, tiempo_par)
    escala = 40 / max_tiempo  # 40 caracteres m√°ximo
    
    barra_sec = "‚ñà" * int(tiempo_sec * escala)
    barra_par = "‚ñà" * int(tiempo_par * escala)
    
    print(f"   Secuencial: {barra_sec} {tiempo_sec:.2f}s")
    print(f"   Paralelo:   {barra_par} {tiempo_par:.2f}s")
    
    # Interpretaci√≥n
    print(f"\nüí° INTERPRETACI√ìN:")
    if metricas['speedup'] >= 4:
        print(f"   ‚ú® ¬°Excelente mejora de rendimiento! El procesamiento paralelo brilla.")
    elif metricas['speedup'] >= 2.5:
        print(f"   üëç Muy buena mejora de rendimiento")
    elif metricas['speedup'] >= 1.5:
        print(f"   ‚úì Mejora moderada de rendimiento")
    else:
        print(f"   ‚ö†Ô∏è  Mejora limitada (posible overhead o im√°genes muy peque√±as)")
    
    print(f"\nüìù NOTA:")
    print(f"   El procesamiento de im√°genes es CPU-intensivo, por lo que")
    print(f"   el paralelismo suele ofrecer ganancias significativas.")
    print("="*70 + "\n")


def main():
    """
    Funci√≥n principal del comparador.
    """
    print("\n" + "="*70)
    print("üî¨ COMPARADOR DE RENDIMIENTO - PROCESAMIENTO DE IM√ÅGENES")
    print("="*70)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üñ•Ô∏è  Sistema: {multiprocessing.cpu_count()} n√∫cleos detectados")
    print("="*70)
    
    # Verificar Pillow
    if not verificar_pillow():
        return
    
    # Buscar im√°genes
    carpeta_entrada = Path(__file__).parent / "imagenes_entrada"
    
    if not carpeta_entrada.exists():
        print(f"\n‚ùå Error: La carpeta 'imagenes_entrada' no existe.")
        print("Por favor, ejecuta primero version3_secuencial.py o version3_paralelo.py")
        return
    
    # Buscar im√°genes
    extensiones = ['*.jpg', '*.jpeg', '*.png', '*.bmp', '*.gif']
    imagenes = []
    for ext in extensiones:
        imagenes.extend(list(carpeta_entrada.glob(ext)))
        imagenes.extend(list(carpeta_entrada.glob(ext.upper())))
    
    if not imagenes:
        print(f"\n‚ùå Error: No se encontraron im√°genes en '{carpeta_entrada}'")
        print("üì∏ Formatos soportados: .jpg, .jpeg, .png, .bmp, .gif")
        return
    
    imagenes = [str(img) for img in imagenes]
    
    print(f"\nüìÇ Im√°genes encontradas: {len(imagenes)}")
    for imagen in imagenes:
        tamanio_kb = os.path.getsize(imagen) / 1024
        print(f"   - {os.path.basename(imagen)} ({tamanio_kb:.2f} KB)")
    
    # Crear carpetas de salida para comparaci√≥n
    carpeta_salida_sec = Path(__file__).parent / "imagenes_salida_comparacion" / "secuencial"
    carpeta_salida_par = Path(__file__).parent / "imagenes_salida_comparacion" / "paralelo"
    
    carpeta_salida_sec.mkdir(parents=True, exist_ok=True)
    carpeta_salida_par.mkdir(parents=True, exist_ok=True)
    
    # Definir operaciones (combo est√°ndar)
    operaciones = [
        {'tipo': 'blur'},
        {'tipo': 'escala_grises'},
        {'tipo': 'redimensionar', 'ancho': 800, 'alto': 600}
    ]
    
    print(f"\nüé® Operaciones a aplicar: {', '.join([op['tipo'] for op in operaciones])}")
    
    # Ejecutar pruebas
    print("\n" + "="*70)
    print("üèÉ INICIANDO PRUEBAS COMPARATIVAS")
    print("="*70)
    
    # Prueba secuencial
    resultados_sec, tiempo_sec = ejecutar_prueba_secuencial(
        imagenes, str(carpeta_salida_sec), operaciones
    )
    
    # Peque√±a pausa entre pruebas
    time.sleep(1)
    
    # Prueba paralela
    num_procesos = multiprocessing.cpu_count()
    resultados_par, tiempo_par = ejecutar_prueba_paralelo(
        imagenes, str(carpeta_salida_par), operaciones, num_procesos
    )
    
    # Calcular m√©tricas
    metricas = calcular_metricas(tiempo_sec, tiempo_par, num_procesos)
    
    # Mostrar comparaci√≥n
    mostrar_comparacion(tiempo_sec, tiempo_par, metricas, resultados_sec, resultados_par)
    
    # Informaci√≥n de salida
    print(f"üìÅ Resultados guardados en:")
    print(f"   Secuencial: {carpeta_salida_sec}")
    print(f"   Paralelo:   {carpeta_salida_par}")
    
    print("\n" + "="*70)
    print("‚úÖ COMPARACI√ìN COMPLETADA")
    print("="*70 + "\n")


if __name__ == "__main__":
    main()

```
**generador_imagenes.py**
```python
"""
GENERADOR DE IM√ÅGENES DE EJEMPLO
=================================
Este script genera im√°genes de ejemplo para probar el procesamiento
paralelo de im√°genes de la Versi√≥n 3.0.

Genera im√°genes con diferentes patrones, colores y tama√±os.

Requiere: pip install Pillow
"""

from PIL import Image, ImageDraw, ImageFont
import os
from pathlib import Path
import random


def verificar_pillow():
    """Verifica que Pillow est√© instalado."""
    try:
        import PIL
        return True
    except ImportError:
        print("\n‚ùå ERROR: La biblioteca Pillow no est√° instalada.")
        print("\nüì¶ Para instalar Pillow, ejecuta:")
        print("   pip install Pillow")
        return False


def generar_imagen_colores(ancho, alto, nombre_archivo):
    """
    Genera una imagen con bloques de colores.
    
    Args:
        ancho: Ancho de la imagen
        alto: Alto de la imagen
        nombre_archivo: Ruta donde guardar la imagen
    """
    imagen = Image.new('RGB', (ancho, alto))
    draw = ImageDraw.Draw(imagen)
    
    # Dividir en cuadrantes de colores
    colores = [
        (255, 0, 0),    # Rojo
        (0, 255, 0),    # Verde
        (0, 0, 255),    # Azul
        (255, 255, 0),  # Amarillo
        (255, 0, 255),  # Magenta
        (0, 255, 255),  # Cyan
    ]
    
    cuadrantes_x = 3
    cuadrantes_y = 2
    ancho_cuadrante = ancho // cuadrantes_x
    alto_cuadrante = alto // cuadrantes_y
    
    idx_color = 0
    for i in range(cuadrantes_y):
        for j in range(cuadrantes_x):
            x1 = j * ancho_cuadrante
            y1 = i * alto_cuadrante
            x2 = x1 + ancho_cuadrante
            y2 = y1 + alto_cuadrante
            
            draw.rectangle([x1, y1, x2, y2], fill=colores[idx_color % len(colores)])
            idx_color += 1
    
    imagen.save(nombre_archivo, 'JPEG', quality=95)
    print(f"‚úÖ Generada: {os.path.basename(nombre_archivo)}")


def generar_imagen_gradiente(ancho, alto, nombre_archivo):
    """
    Genera una imagen con gradiente de colores.
    
    Args:
        ancho: Ancho de la imagen
        alto: Alto de la imagen
        nombre_archivo: Ruta donde guardar la imagen
    """
    imagen = Image.new('RGB', (ancho, alto))
    draw = ImageDraw.Draw(imagen)
    
    for y in range(alto):
        # Gradiente de rojo a azul
        r = int(255 * (1 - y / alto))
        b = int(255 * (y / alto))
        g = 100
        
        draw.line([(0, y), (ancho, y)], fill=(r, g, b))
    
    imagen.save(nombre_archivo, 'JPEG', quality=95)
    print(f"‚úÖ Generada: {os.path.basename(nombre_archivo)}")


def generar_imagen_patron(ancho, alto, nombre_archivo):
    """
    Genera una imagen con patr√≥n geom√©trico.
    
    Args:
        ancho: Ancho de la imagen
        alto: Alto de la imagen
        nombre_archivo: Ruta donde guardar la imagen
    """
    imagen = Image.new('RGB', (ancho, alto), color=(255, 255, 255))
    draw = ImageDraw.Draw(imagen)
    
    # Dibujar c√≠rculos en patr√≥n
    radio = 30
    espaciado = 60
    
    for y in range(0, alto, espaciado):
        for x in range(0, ancho, espaciado):
            color = (
                random.randint(50, 255),
                random.randint(50, 255),
                random.randint(50, 255)
            )
            draw.ellipse([x-radio, y-radio, x+radio, y+radio], fill=color, outline=(0, 0, 0))
    
    imagen.save(nombre_archivo, 'JPEG', quality=95)
    print(f"‚úÖ Generada: {os.path.basename(nombre_archivo)}")


def generar_imagen_rayas(ancho, alto, nombre_archivo):
    """
    Genera una imagen con rayas horizontales.
    
    Args:
        ancho: Ancho de la imagen
        alto: Alto de la imagen
        nombre_archivo: Ruta donde guardar la imagen
    """
    imagen = Image.new('RGB', (ancho, alto))
    draw = ImageDraw.Draw(imagen)
    
    altura_raya = 40
    colores = [
        (255, 100, 100),
        (100, 255, 100),
        (100, 100, 255),
        (255, 255, 100),
        (255, 100, 255),
        (100, 255, 255),
    ]
    
    y = 0
    idx = 0
    while y < alto:
        draw.rectangle([0, y, ancho, y + altura_raya], fill=colores[idx % len(colores)])
        y += altura_raya
        idx += 1
    
    imagen.save(nombre_archivo, 'JPEG', quality=95)
    print(f"‚úÖ Generada: {os.path.basename(nombre_archivo)}")


def generar_imagen_texto(ancho, alto, nombre_archivo, texto):
    """
    Genera una imagen con texto.
    
    Args:
        ancho: Ancho de la imagen
        alto: Alto de la imagen
        nombre_archivo: Ruta donde guardar la imagen
        texto: Texto a dibujar
    """
    imagen = Image.new('RGB', (ancho, alto), color=(240, 240, 240))
    draw = ImageDraw.Draw(imagen)
    
    # Fondo con gradiente
    for y in range(alto):
        color_val = int(240 - (y / alto) * 80)
        draw.line([(0, y), (ancho, y)], fill=(color_val, color_val, 255))
    
    # Intentar usar una fuente, si no est√° disponible usar la por defecto
    try:
        # Tama√±o de fuente basado en el tama√±o de la imagen
        font_size = ancho // 15
        font = ImageFont.truetype("arial.ttf", font_size)
    except:
        font = ImageFont.load_default()
    
    # Dibujar texto centrado
    bbox = draw.textbbox((0, 0), texto, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    
    x = (ancho - text_width) // 2
    y = (alto - text_height) // 2
    
    # Sombra del texto
    draw.text((x+3, y+3), texto, fill=(100, 100, 100), font=font)
    # Texto principal
    draw.text((x, y), texto, fill=(255, 255, 255), font=font)
    
    imagen.save(nombre_archivo, 'JPEG', quality=95)
    print(f"‚úÖ Generada: {os.path.basename(nombre_archivo)}")


def generar_imagen_compleja(ancho, alto, nombre_archivo):
    """
    Genera una imagen compleja con m√∫ltiples elementos.
    
    Args:
        ancho: Ancho de la imagen
        alto: Alto de la imagen
        nombre_archivo: Ruta donde guardar la imagen
    """
    imagen = Image.new('RGB', (ancho, alto), color=(20, 20, 40))
    draw = ImageDraw.Draw(imagen)
    
    # Fondo con estrellas
    for _ in range(200):
        x = random.randint(0, ancho)
        y = random.randint(0, alto)
        brillo = random.randint(150, 255)
        draw.point((x, y), fill=(brillo, brillo, brillo))
    
    # C√≠rculos de colores
    for _ in range(50):
        x = random.randint(0, ancho)
        y = random.randint(0, alto)
        radio = random.randint(10, 50)
        color = (
            random.randint(100, 255),
            random.randint(100, 255),
            random.randint(100, 255)
        )
        draw.ellipse([x-radio, y-radio, x+radio, y+radio], fill=color)
    
    imagen.save(nombre_archivo, 'PNG')
    print(f"‚úÖ Generada: {os.path.basename(nombre_archivo)}")


def main():
    """
    Funci√≥n principal del generador.
    """
    print("\n" + "="*70)
    print("üé® GENERADOR DE IM√ÅGENES DE EJEMPLO")
    print("="*70)
    
    if not verificar_pillow():
        return
    
    # Crear carpeta de im√°genes
    carpeta = Path(__file__).parent / "imagenes_entrada"
    carpeta.mkdir(exist_ok=True)
    
    print(f"\nüìÅ Carpeta de destino: {carpeta}")
    print("\nüé® Generando im√°genes de ejemplo...\n")
    
    # Generar diferentes tipos de im√°genes
    generar_imagen_colores(1200, 800, str(carpeta / "imagen1_colores.jpg"))
    generar_imagen_gradiente(1600, 1200, str(carpeta / "imagen2_gradiente.jpg"))
    generar_imagen_patron(1400, 1000, str(carpeta / "imagen3_patron.jpg"))
    generar_imagen_rayas(1800, 1200, str(carpeta / "imagen4_rayas.jpg"))
    generar_imagen_texto(1600, 900, str(carpeta / "imagen5_texto.jpg"), "PYTHON")
    generar_imagen_texto(1400, 1000, str(carpeta / "imagen6_multicore.jpg"), "MULTICORE")
    generar_imagen_compleja(2000, 1500, str(carpeta / "imagen7_compleja.png"))
    
    print("\n" + "="*70)
    print("‚úÖ GENERACI√ìN COMPLETADA")
    print("="*70)
    print(f"\nüìä Total de im√°genes generadas: 7")
    print(f"üìÅ Ubicaci√≥n: {carpeta}")
    print("\nüí° Ahora puedes ejecutar:")
    print("   python version3_secuencial.py")
    print("   python version3_paralelo.py")
    print("   python comparador_v3.py")
    print("\n" + "="*70 + "\n")


if __name__ == "__main__":
    main()

```
**paralelo.py**
```python
"""
VERSI√ìN 2 - PROCESAMIENTO PARALELO DE ARCHIVOS (MULTIN√öCLEO)
=============================================================
Este programa lee m√∫ltiples archivos de texto de forma PARALELA
y realiza an√°lisis estad√≠stico del contenido.

Tarea: Leer archivos y calcular estad√≠sticas de texto
Ahora usando multiprocessing para aprovechar el multin√∫cleo.
"""

import time
import os
import multiprocessing
from datetime import datetime
from pathlib import Path
import re


def contar_palabras(texto):
    """
    Cuenta las palabras en un texto.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        N√∫mero de palabras
    """
    palabras = texto.split()
    return len(palabras)


def contar_lineas(texto):
    """
    Cuenta las l√≠neas en un texto.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        N√∫mero de l√≠neas
    """
    return len(texto.splitlines())


def contar_caracteres(texto):
    """
    Cuenta los caracteres en un texto.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        Diccionario con conteos de caracteres
    """
    return {
        'total': len(texto),
        'sin_espacios': len(texto.replace(' ', '').replace('\n', '').replace('\t', '')),
        'espacios': texto.count(' '),
        'saltos_linea': texto.count('\n')
    }


def encontrar_palabras_frecuentes(texto, top_n=10):
    """
    Encuentra las palabras m√°s frecuentes en el texto.
    
    Args:
        texto: String con el contenido del texto
        top_n: N√∫mero de palabras m√°s frecuentes a retornar
    
    Returns:
        Lista de tuplas (palabra, frecuencia)
    """
    # Convertir a min√∫sculas y extraer palabras
    palabras = re.findall(r'\b\w+\b', texto.lower())
    
    # Contar frecuencias
    frecuencias = {}
    for palabra in palabras:
        if len(palabra) > 2:  # Ignorar palabras muy cortas
            frecuencias[palabra] = frecuencias.get(palabra, 0) + 1
    
    # Ordenar por frecuencia
    palabras_ordenadas = sorted(frecuencias.items(), key=lambda x: x[1], reverse=True)
    
    return palabras_ordenadas[:top_n]


def calcular_promedio_longitud_palabra(texto):
    """
    Calcula la longitud promedio de las palabras.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        Promedio de longitud de palabras
    """
    palabras = re.findall(r'\b\w+\b', texto)
    if not palabras:
        return 0
    
    total_caracteres = sum(len(palabra) for palabra in palabras)
    return total_caracteres / len(palabras)


def analizar_archivo(ruta_archivo):
    """
    Lee y analiza un archivo de texto.
    Esta funci√≥n ser√° ejecutada en PARALELO por diferentes procesos.
    
    Args:
        ruta_archivo: Ruta del archivo a procesar
    
    Returns:
        Diccionario con las estad√≠sticas del archivo
    """
    inicio = time.time()
    proceso_id = multiprocessing.current_process().name
    
    print(f"  üîÑ [{proceso_id}] Procesando: {os.path.basename(ruta_archivo)}")
    
    try:
        # Leer el archivo
        with open(ruta_archivo, 'r', encoding='utf-8') as f:
            contenido = f.read()
        
        # Calcular estad√≠sticas
        num_palabras = contar_palabras(contenido)
        num_lineas = contar_lineas(contenido)
        stats_caracteres = contar_caracteres(contenido)
        palabras_frecuentes = encontrar_palabras_frecuentes(contenido)
        promedio_longitud = calcular_promedio_longitud_palabra(contenido)
        
        tiempo = time.time() - inicio
        
        # Obtener tama√±o del archivo
        tamanio_bytes = os.path.getsize(ruta_archivo)
        tamanio_kb = tamanio_bytes / 1024
        
        # Mostrar resultado inmediatamente
        print(f"  ‚úÖ [{proceso_id}] {os.path.basename(ruta_archivo)}: "
              f"{num_palabras} palabras | {num_lineas} l√≠neas | "
              f"{tamanio_kb:.2f} KB | {tiempo:.3f}s")
        
        return {
            'archivo': os.path.basename(ruta_archivo),
            'ruta': ruta_archivo,
            'exito': True,
            'tamanio_kb': round(tamanio_kb, 2),
            'num_lineas': num_lineas,
            'num_palabras': num_palabras,
            'num_caracteres': stats_caracteres['total'],
            'num_caracteres_sin_espacios': stats_caracteres['sin_espacios'],
            'promedio_longitud_palabra': round(promedio_longitud, 2),
            'palabras_frecuentes': palabras_frecuentes[:5],  # Top 5
            'tiempo_proceso': tiempo,
            'proceso': proceso_id
        }
    
    except FileNotFoundError:
        print(f"  ‚ùå [{proceso_id}] Error: Archivo no encontrado - {os.path.basename(ruta_archivo)}")
        return {
            'archivo': os.path.basename(ruta_archivo),
            'ruta': ruta_archivo,
            'exito': False,
            'error': 'Archivo no encontrado',
            'tiempo_proceso': time.time() - inicio,
            'proceso': proceso_id
        }
    
    except Exception as e:
        print(f"  ‚ùå [{proceso_id}] Error: {str(e)} - {os.path.basename(ruta_archivo)}")
        return {
            'archivo': os.path.basename(ruta_archivo),
            'ruta': ruta_archivo,
            'exito': False,
            'error': str(e),
            'tiempo_proceso': time.time() - inicio,
            'proceso': proceso_id
        }


def procesar_archivos_paralelo(lista_archivos, num_procesos=None):
    """
    Procesa una lista de archivos de forma PARALELA.
    Distribuye los archivos entre todos los n√∫cleos disponibles.
    
    Args:
        lista_archivos: Lista de rutas de archivos a procesar
        num_procesos: N√∫mero de procesos a usar (None = todos los n√∫cleos)
    
    Returns:
        Tupla (lista de resultados, tiempo total)
    """
    if num_procesos is None:
        num_procesos = multiprocessing.cpu_count()
    
    print("\n" + "="*70)
    print("üöÄ INICIANDO PROCESAMIENTO PARALELO DE ARCHIVOS")
    print("="*70)
    print(f"üìä Archivos a procesar: {len(lista_archivos)}")
    print(f"üñ•Ô∏è  N√∫cleos disponibles: {multiprocessing.cpu_count()}")
    print(f"‚öôÔ∏è  Procesos a usar: {num_procesos}")
    print("="*70 + "\n")
    
    inicio_total = time.time()
    
    # Crear pool de procesos
    with multiprocessing.Pool(processes=num_procesos) as pool:
        # Distribuir el trabajo entre los procesos
        resultados = pool.map(analizar_archivo, lista_archivos)
    
    tiempo_total = time.time() - inicio_total
    
    # Mostrar resumen
    print("\n" + "="*70)
    print("üìà RESUMEN DEL PROCESAMIENTO PARALELO")
    print("="*70)
    
    archivos_exitosos = [r for r in resultados if r['exito']]
    
    if archivos_exitosos:
        total_palabras = sum(r['num_palabras'] for r in archivos_exitosos)
        total_lineas = sum(r['num_lineas'] for r in archivos_exitosos)
        total_caracteres = sum(r['num_caracteres'] for r in archivos_exitosos)
        
        print(f"‚úÖ Archivos procesados exitosamente: {len(archivos_exitosos)}/{len(lista_archivos)}")
        print(f"üìù Total de palabras: {total_palabras:,}")
        print(f"üìÑ Total de l√≠neas: {total_lineas:,}")
        print(f"üî§ Total de caracteres: {total_caracteres:,}")
    
    print(f"‚è±Ô∏è  Tiempo total: {tiempo_total:.2f} segundos")
    print(f"‚ö° Promedio por archivo: {tiempo_total/len(lista_archivos):.2f} segundos")
    
    # Calcular speedup te√≥rico
    tiempo_proceso_total = sum(r['tiempo_proceso'] for r in resultados)
    print(f"üî• Speedup estimado: {tiempo_proceso_total/tiempo_total:.2f}x")
    print("="*70 + "\n")
    
    return resultados, tiempo_total


def main():
    """
    Funci√≥n principal del programa.
    """
    print("\n" + "="*70)
    print("üöÄ VERSI√ìN 2 - PROCESAMIENTO PARALELO DE ARCHIVOS")
    print("="*70)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*70)
    
    # Buscar archivos .txt en la carpeta actual
    carpeta_datos = Path(__file__).parent / "datos_ejemplo"
    
    if not carpeta_datos.exists():
        print(f"\n‚ö†Ô∏è  La carpeta 'datos_ejemplo' no existe.")
        print(f"üìÅ Creando carpeta: {carpeta_datos}")
        carpeta_datos.mkdir(exist_ok=True)
        print("‚ÑπÔ∏è  Por favor, coloca archivos .txt en la carpeta 'datos_ejemplo' y ejecuta nuevamente.")
        return
    
    # Buscar archivos .txt
    archivos_txt = list(carpeta_datos.glob("*.txt"))
    
    if not archivos_txt:
        print(f"\n‚ö†Ô∏è  No se encontraron archivos .txt en '{carpeta_datos}'")
        print("‚ÑπÔ∏è  Por favor, coloca archivos .txt en la carpeta y ejecuta nuevamente.")
        return
    
    archivos_txt = [str(archivo) for archivo in archivos_txt]
    
    print(f"\nüìÇ Archivos encontrados: {len(archivos_txt)}")
    for archivo in archivos_txt:
        print(f"   - {os.path.basename(archivo)}")
    
    # Procesar archivos
    resultados, tiempo_total = procesar_archivos_paralelo(archivos_txt)
    
    # Mostrar detalles de cada archivo procesado
    print("\n" + "="*70)
    print("üìä DETALLES POR ARCHIVO")
    print("="*70)
    
    for resultado in resultados:
        if resultado['exito']:
            print(f"\nüìÑ {resultado['archivo']} (Proceso: {resultado['proceso']})")
            print(f"   - Tama√±o: {resultado['tamanio_kb']} KB")
            print(f"   - L√≠neas: {resultado['num_lineas']:,}")
            print(f"   - Palabras: {resultado['num_palabras']:,}")
            print(f"   - Caracteres: {resultado['num_caracteres']:,}")
            print(f"   - Promedio longitud palabra: {resultado['promedio_longitud_palabra']} caracteres")
            print(f"   - Top 5 palabras frecuentes:")
            for palabra, frecuencia in resultado['palabras_frecuentes']:
                print(f"      ‚Ä¢ {palabra}: {frecuencia} veces")
            print(f"   - Tiempo: {resultado['tiempo_proceso']:.3f}s")
    
    print("\n" + "="*70)
    print("‚úÖ PROCESAMIENTO COMPLETADO")
    print("="*70 + "\n")


if __name__ == "__main__":
    main()

```
**secuencial.py**
```python
"""
VERSI√ìN 2 - PROCESAMIENTO SECUENCIAL DE ARCHIVOS
=================================================
Este programa lee m√∫ltiples archivos de texto de forma SECUENCIAL
y realiza an√°lisis estad√≠stico del contenido.

Tarea: Leer archivos y calcular estad√≠sticas de texto
Procesa un archivo tras otro en un solo n√∫cleo del procesador.
"""

import time
import os
from datetime import datetime
from pathlib import Path
import re


def contar_palabras(texto):
    """
    Cuenta las palabras en un texto.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        N√∫mero de palabras
    """
    palabras = texto.split()
    return len(palabras)


def contar_lineas(texto):
    """
    Cuenta las l√≠neas en un texto.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        N√∫mero de l√≠neas
    """
    return len(texto.splitlines())


def contar_caracteres(texto):
    """
    Cuenta los caracteres en un texto.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        Diccionario con conteos de caracteres
    """
    return {
        'total': len(texto),
        'sin_espacios': len(texto.replace(' ', '').replace('\n', '').replace('\t', '')),
        'espacios': texto.count(' '),
        'saltos_linea': texto.count('\n')
    }


def encontrar_palabras_frecuentes(texto, top_n=10):
    """
    Encuentra las palabras m√°s frecuentes en el texto.
    
    Args:
        texto: String con el contenido del texto
        top_n: N√∫mero de palabras m√°s frecuentes a retornar
    
    Returns:
        Lista de tuplas (palabra, frecuencia)
    """
    # Convertir a min√∫sculas y extraer palabras
    palabras = re.findall(r'\b\w+\b', texto.lower())
    
    # Contar frecuencias
    frecuencias = {}
    for palabra in palabras:
        if len(palabra) > 2:  # Ignorar palabras muy cortas
            frecuencias[palabra] = frecuencias.get(palabra, 0) + 1
    
    # Ordenar por frecuencia
    palabras_ordenadas = sorted(frecuencias.items(), key=lambda x: x[1], reverse=True)
    
    return palabras_ordenadas[:top_n]


def calcular_promedio_longitud_palabra(texto):
    """
    Calcula la longitud promedio de las palabras.
    
    Args:
        texto: String con el contenido del texto
    
    Returns:
        Promedio de longitud de palabras
    """
    palabras = re.findall(r'\b\w+\b', texto)
    if not palabras:
        return 0
    
    total_caracteres = sum(len(palabra) for palabra in palabras)
    return total_caracteres / len(palabras)


def analizar_archivo(ruta_archivo):
    """
    Lee y analiza un archivo de texto.
    
    Args:
        ruta_archivo: Ruta del archivo a procesar
    
    Returns:
        Diccionario con las estad√≠sticas del archivo
    """
    inicio = time.time()
    
    try:
        # Leer el archivo
        with open(ruta_archivo, 'r', encoding='utf-8') as f:
            contenido = f.read()
        
        # Calcular estad√≠sticas
        num_palabras = contar_palabras(contenido)
        num_lineas = contar_lineas(contenido)
        stats_caracteres = contar_caracteres(contenido)
        palabras_frecuentes = encontrar_palabras_frecuentes(contenido)
        promedio_longitud = calcular_promedio_longitud_palabra(contenido)
        
        tiempo = time.time() - inicio
        
        # Obtener tama√±o del archivo
        tamanio_bytes = os.path.getsize(ruta_archivo)
        tamanio_kb = tamanio_bytes / 1024
        
        return {
            'archivo': os.path.basename(ruta_archivo),
            'ruta': ruta_archivo,
            'exito': True,
            'tamanio_kb': round(tamanio_kb, 2),
            'num_lineas': num_lineas,
            'num_palabras': num_palabras,
            'num_caracteres': stats_caracteres['total'],
            'num_caracteres_sin_espacios': stats_caracteres['sin_espacios'],
            'promedio_longitud_palabra': round(promedio_longitud, 2),
            'palabras_frecuentes': palabras_frecuentes[:5],  # Top 5
            'tiempo_proceso': tiempo
        }
    
    except FileNotFoundError:
        return {
            'archivo': os.path.basename(ruta_archivo),
            'ruta': ruta_archivo,
            'exito': False,
            'error': 'Archivo no encontrado',
            'tiempo_proceso': time.time() - inicio
        }
    
    except Exception as e:
        return {
            'archivo': os.path.basename(ruta_archivo),
            'ruta': ruta_archivo,
            'exito': False,
            'error': str(e),
            'tiempo_proceso': time.time() - inicio
        }


def procesar_archivos_secuencial(lista_archivos):
    """
    Procesa una lista de archivos de forma SECUENCIAL.
    Cada archivo se procesa uno despu√©s del otro.
    
    Args:
        lista_archivos: Lista de rutas de archivos a procesar
    
    Returns:
        Lista con los resultados de cada archivo
    """
    print("\n" + "="*70)
    print("üìÑ INICIANDO PROCESAMIENTO SECUENCIAL DE ARCHIVOS")
    print("="*70)
    print(f"üìä Archivos a procesar: {len(lista_archivos)}")
    print(f"üñ•Ô∏è  Modo: UN SOLO N√öCLEO (secuencial)")
    print("="*70 + "\n")
    
    inicio_total = time.time()
    resultados = []
    
    # Procesar cada archivo secuencialmente
    for i, archivo in enumerate(lista_archivos, 1):
        print(f"üîÑ Procesando archivo {i}/{len(lista_archivos)}: {os.path.basename(archivo)}")
        resultado = analizar_archivo(archivo)
        resultados.append(resultado)
        
        if resultado['exito']:
            print(f"  ‚úÖ {resultado['num_palabras']} palabras | "
                  f"{resultado['num_lineas']} l√≠neas | "
                  f"{resultado['tamanio_kb']} KB | "
                  f"{resultado['tiempo_proceso']:.3f}s\n")
        else:
            print(f"  ‚ùå Error: {resultado['error']}\n")
    
    tiempo_total = time.time() - inicio_total
    
    # Mostrar resumen
    print("="*70)
    print("üìà RESUMEN DEL PROCESAMIENTO SECUENCIAL")
    print("="*70)
    
    archivos_exitosos = [r for r in resultados if r['exito']]
    
    if archivos_exitosos:
        total_palabras = sum(r['num_palabras'] for r in archivos_exitosos)
        total_lineas = sum(r['num_lineas'] for r in archivos_exitosos)
        total_caracteres = sum(r['num_caracteres'] for r in archivos_exitosos)
        
        print(f"‚úÖ Archivos procesados exitosamente: {len(archivos_exitosos)}/{len(lista_archivos)}")
        print(f"üìù Total de palabras: {total_palabras:,}")
        print(f"üìÑ Total de l√≠neas: {total_lineas:,}")
        print(f"üî§ Total de caracteres: {total_caracteres:,}")
    
    print(f"‚è±Ô∏è  Tiempo total: {tiempo_total:.2f} segundos")
    print(f"‚ö° Promedio por archivo: {tiempo_total/len(lista_archivos):.2f} segundos")
    print("="*70 + "\n")
    
    return resultados, tiempo_total


def main():
    """
    Funci√≥n principal del programa.
    """
    print("\n" + "="*70)
    print("üöÄ VERSI√ìN 2 - PROCESAMIENTO SECUENCIAL DE ARCHIVOS")
    print("="*70)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*70)
    
    # Buscar archivos .txt en la carpeta actual
    carpeta_datos = Path(__file__).parent / "datos_ejemplo"
    
    if not carpeta_datos.exists():
        print(f"\n‚ö†Ô∏è  La carpeta 'datos_ejemplo' no existe.")
        print(f"üìÅ Creando carpeta: {carpeta_datos}")
        carpeta_datos.mkdir(exist_ok=True)
        print("‚ÑπÔ∏è  Por favor, coloca archivos .txt en la carpeta 'datos_ejemplo' y ejecuta nuevamente.")
        return
    
    # Buscar archivos .txt
    archivos_txt = list(carpeta_datos.glob("*.txt"))
    
    if not archivos_txt:
        print(f"\n‚ö†Ô∏è  No se encontraron archivos .txt en '{carpeta_datos}'")
        print("‚ÑπÔ∏è  Por favor, coloca archivos .txt en la carpeta y ejecuta nuevamente.")
        return
    
    archivos_txt = [str(archivo) for archivo in archivos_txt]
    
    print(f"\nüìÇ Archivos encontrados: {len(archivos_txt)}")
    for archivo in archivos_txt:
        print(f"   - {os.path.basename(archivo)}")
    
    # Procesar archivos
    resultados, tiempo_total = procesar_archivos_secuencial(archivos_txt)
    
    # Mostrar detalles de cada archivo procesado
    print("\n" + "="*70)
    print("üìä DETALLES POR ARCHIVO")
    print("="*70)
    
    for resultado in resultados:
        if resultado['exito']:
            print(f"\nüìÑ {resultado['archivo']}")
            print(f"   - Tama√±o: {resultado['tamanio_kb']} KB")
            print(f"   - L√≠neas: {resultado['num_lineas']:,}")
            print(f"   - Palabras: {resultado['num_palabras']:,}")
            print(f"   - Caracteres: {resultado['num_caracteres']:,}")
            print(f"   - Promedio longitud palabra: {resultado['promedio_longitud_palabra']} caracteres")
            print(f"   - Top 5 palabras frecuentes:")
            for palabra, frecuencia in resultado['palabras_frecuentes']:
                print(f"      ‚Ä¢ {palabra}: {frecuencia} veces")
            print(f"   - Tiempo: {resultado['tiempo_proceso']:.3f}s")
    
    print("\n" + "="*70)
    print("‚úÖ PROCESAMIENTO COMPLETADO")
    print("="*70 + "\n")


if __name__ == "__main__":
    main()

```
**servidor.py**
```python
"""
VERSI√ìN 4 - SERVIDOR WEBSOCKET (BACKEND)
=========================================
Backend as√≠ncrono que expone el procesamiento multin√∫cleo en tiempo real
a trav√©s de WebSockets. Permite controlar y monitorizar el procesamiento
de im√°genes desde el dashboard web.

Tecnolog√≠as:
  - asyncio: Bucle de eventos as√≠ncrono
  - websockets: Protocolo WebSocket
  - psutil: Monitorizaci√≥n de CPU y RAM
  - concurrent.futures: Pool de procesos integrado con asyncio
  - multiprocessing: Detecci√≥n de n√∫cleos

Requiere:
  pip install websockets psutil Pillow
"""

import asyncio
import json
import time
import multiprocessing
import os
import sys
from pathlib import Path
from datetime import datetime
from concurrent.futures import ProcessPoolExecutor

try:
    import psutil
    PSUTIL_DISPONIBLE = True
except ImportError:
    PSUTIL_DISPONIBLE = False

try:
    import websockets
    from websockets.exceptions import ConnectionClosed
except ImportError:
    print("‚ùå ERROR: websockets no est√° instalado.")
    print("   Ejecuta: pip install websockets")
    sys.exit(1)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Importar procesador de im√°genes de V3
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
try:
    from version3_paralelo import procesar_imagen_wrapper
    PILLOW_DISPONIBLE = True
except ImportError:
    PILLOW_DISPONIBLE = False

    def procesar_imagen_wrapper(args):
        """Stub cuando Pillow no est√° instalado."""
        import time
        time.sleep(0.5)
        ruta_entrada, ruta_salida, _ = args
        return {
            'archivo': os.path.basename(ruta_entrada),
            'exito': False,
            'error': 'Pillow no instalado',
            'tiempo_proceso': 0.5,
            'proceso': multiprocessing.current_process().name
        }


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Estado global del servidor (protegido con asyncio.Lock)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
estado = {
    "state": "idle",       # idle | running | stopping
    "current": 0,
    "total": 0,
    "workers": multiprocessing.cpu_count(),
    "inicio_proceso": None,
    "cpu_count": multiprocessing.cpu_count(),
    "pillow": PILLOW_DISPONIBLE,
    "psutil": PSUTIL_DISPONIBLE,
}

clientes: set = set()
estado_lock = asyncio.Lock() if False else None   # se crea en main()
cancelar_procesamiento = False


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Utilidades de comunicaci√≥n
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def broadcast(mensaje: dict):
    """Env√≠a un mensaje JSON a TODOS los clientes conectados."""
    if not clientes:
        return
    datos = json.dumps(mensaje, ensure_ascii=False)
    await asyncio.gather(
        *[ws.send(datos) for ws in list(clientes)],
        return_exceptions=True
    )


async def log(mensaje: str, nivel: str = "info"):
    """Env√≠a un mensaje de log a todos los clientes."""
    await broadcast({
        "type": "log",
        "data": {
            "message": mensaje,
            "level": nivel,
            "timestamp": datetime.now().strftime("%H:%M:%S")
        }
    })


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Monitorizaci√≥n de recursos del sistema
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def tarea_monitor_cpu():
    """Tarea de background: env√≠a estad√≠sticas de CPU y RAM cada ~0.8s."""
    if not PSUTIL_DISPONIBLE:
        return

    # Primera llamada sin intervalo (normalmente devuelve 0)
    psutil.cpu_percent(interval=None, percpu=True)

    while True:
        try:
            cores = psutil.cpu_percent(interval=None, percpu=True)
            total = psutil.cpu_percent(interval=None)
            ram = psutil.virtual_memory()

            await broadcast({
                "type": "cpu_stats",
                "data": {
                    "cores": cores,
                    "total": round(total, 1),
                    "ram_percent": round(ram.percent, 1),
                    "ram_used_gb": round(ram.used  / (1024 ** 3), 2),
                    "ram_total_gb": round(ram.total / (1024 ** 3), 2),
                }
            })
        except Exception:
            pass

        await asyncio.sleep(0.8)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# N√∫cleo del procesamiento
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def procesar_imagenes_async(operaciones: list, num_workers: int):
    """
    Procesa im√°genes usando ProcessPoolExecutor integrado con asyncio.
    Env√≠a actualizaciones en tiempo real a todos los clientes conectados.
    """
    global estado, cancelar_procesamiento

    carpeta_entrada = Path(__file__).parent / "imagenes_entrada"
    carpeta_salida  = Path(__file__).parent / "imagenes_salida"
    carpeta_salida.mkdir(exist_ok=True)

    # ‚îÄ‚îÄ Buscar im√°genes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    extensiones = ['*.jpg', '*.jpeg', '*.png', '*.bmp', '*.gif']
    imagenes = []
    for ext in extensiones:
        imagenes.extend(carpeta_entrada.glob(ext))
        imagenes.extend(carpeta_entrada.glob(ext.upper()))

    if not imagenes:
        await log("‚ö†Ô∏è  No se encontraron im√°genes en 'imagenes_entrada/'", "warning")
        await log("üí° Ejecuta primero: python generador_imagenes.py", "info")
        estado["state"] = "idle"
        await broadcast({"type": "status", "data": estado})
        return

    total = len(imagenes)
    estado["total"] = total
    estado["current"] = 0
    estado["inicio_proceso"] = time.time()

    await log(f"üìÇ {total} imagen(es) encontrada(s)", "info")
    await log(f"‚öôÔ∏è  Workers: {num_workers} | N√∫cleos: {multiprocessing.cpu_count()}", "info")
    await log(f"üé® Operaciones: {', '.join(op['tipo'] for op in operaciones)}", "info")
    await broadcast({"type": "status", "data": estado})

    # ‚îÄ‚îÄ Preparar tareas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    tareas = []
    for img in imagenes:
        nombre_salida = f"{img.stem}_v4{img.suffix}"
        ruta_salida = carpeta_salida / nombre_salida
        tareas.append((str(img), str(ruta_salida), operaciones))

    inicio_total = time.time()
    resultados = []
    loop = asyncio.get_event_loop()

    # ‚îÄ‚îÄ Ejecutar con ProcessPoolExecutor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    with ProcessPoolExecutor(max_workers=num_workers) as executor:
        futures = [
            loop.run_in_executor(executor, procesar_imagen_wrapper, tarea)
            for tarea in tareas
        ]

        for future in asyncio.as_completed(futures):
            # ‚îÄ‚îÄ Comprobar cancelaci√≥n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if cancelar_procesamiento:
                await log("üõë Procesamiento cancelado por el usuario", "warning")
                # Cancelar futuros pendientes
                for f in futures:
                    f.cancel()
                break

            try:
                resultado = await future
                resultados.append(resultado)
                estado["current"] += 1
                porcentaje = int((estado["current"] / total) * 100)

                # Progreso global
                await broadcast({
                    "type": "progress",
                    "data": {
                        "current":    estado["current"],
                        "total":      total,
                        "percentage": porcentaje,
                        "file":       resultado.get("archivo", ""),
                    }
                })

                # Resultado individual
                if resultado.get("exito"):
                    await broadcast({
                        "type": "result",
                        "data": {
                            "file":           resultado["archivo"],
                            "time":           round(resultado["tiempo_proceso"], 3),
                            "operations":     resultado.get("operaciones_aplicadas", []),
                            "size_before_kb": resultado.get("tamanio_kb_entrada", 0),
                            "size_after_kb":  resultado.get("tamanio_kb_salida",  0),
                            "size_original":  list(resultado.get("tamanio_original", [0, 0])),
                            "size_final":     list(resultado.get("tamanio_final",   [0, 0])),
                            "proceso":        resultado.get("proceso", ""),
                        }
                    })
                    await log(
                        f"‚úÖ  {resultado['archivo']}  ‚Üí  {resultado['tiempo_proceso']:.3f}s",
                        "success"
                    )
                else:
                    await log(
                        f"‚ùå  {resultado['archivo']}: {resultado.get('error', 'error desconocido')}",
                        "error"
                    )

            except Exception as e:
                await log(f"‚ùå Excepci√≥n inesperada: {e}", "error")

    # ‚îÄ‚îÄ M√©tricas finales ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if not cancelar_procesamiento and resultados:
        tiempo_total = time.time() - inicio_total
        exitosos = [r for r in resultados if r.get("exito")]
        suma_tiempos = sum(r.get("tiempo_proceso", 0) for r in resultados)
        speedup    = round(suma_tiempos / tiempo_total, 2) if tiempo_total > 0 else 1.0
        eficiencia = round((speedup / num_workers) * 100, 1)

        await broadcast({
            "type": "metrics",
            "data": {
                "speedup":    speedup,
                "efficiency": eficiencia,
                "total_time": round(tiempo_total, 2),
                "successful": len(exitosos),
                "failed":     len(resultados) - len(exitosos),
                "total":      total,
                "avg_time":   round(tiempo_total / total, 3) if total else 0,
                "workers":    num_workers,
            }
        })

        await log(
            f"üèÅ Finalizado en {tiempo_total:.2f}s  |  "
            f"Speedup: {speedup}x  |  Eficiencia: {eficiencia}%",
            "success"
        )

    # ‚îÄ‚îÄ Restablecer estado ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    cancelar_procesamiento = False
    estado["state"] = "idle"
    await broadcast({"type": "status", "data": estado})


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Manejador de clientes WebSocket
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def manejar_cliente(websocket):
    """Gestiona la conexi√≥n completa de un cliente."""
    global cancelar_procesamiento

    clientes.add(websocket)
    ip = websocket.remote_address[0] if websocket.remote_address else "desconocido"
    ts = datetime.now().strftime("%H:%M:%S")
    print(f"[{ts}]  ‚úÖ  Cliente conectado:     {ip}  (total: {len(clientes)})")

    # ‚îÄ‚îÄ Bienvenida ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    await websocket.send(json.dumps({"type": "status",  "data": estado}))
    await websocket.send(json.dumps({
        "type": "log",
        "data": {
            "message":   f"üîó Conectado al servidor "
                         f"({multiprocessing.cpu_count()} n√∫cleos | "
                         f"Pillow: {'‚úÖ' if PILLOW_DISPONIBLE else '‚ùå'} | "
                         f"psutil: {'‚úÖ' if PSUTIL_DISPONIBLE else '‚ùå'})",
            "level":     "success",
            "timestamp": ts,
        }
    }))

    try:
        async for mensaje in websocket:
            try:
                data   = json.loads(mensaje)
                accion = data.get("action", "")

                # ‚îÄ‚îÄ start ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if accion == "start":
                    if estado["state"] == "idle":
                        payload = data.get("data", {})
                        operaciones = payload.get("operaciones", [
                            {"tipo": "blur"},
                            {"tipo": "escala_grises"},
                            {"tipo": "redimensionar", "ancho": 800, "alto": 600},
                        ])
                        num_workers = max(1, min(
                            payload.get("num_workers", multiprocessing.cpu_count()),
                            multiprocessing.cpu_count()
                        ))
                        estado["state"] = "running"
                        cancelar_procesamiento = False
                        await broadcast({"type": "status", "data": estado})
                        asyncio.create_task(
                            procesar_imagenes_async(operaciones, num_workers)
                        )
                    else:
                        await websocket.send(json.dumps({
                            "type": "log",
                            "data": {
                                "message":   "‚ö†Ô∏è  Ya hay un procesamiento en curso",
                                "level":     "warning",
                                "timestamp": datetime.now().strftime("%H:%M:%S"),
                            }
                        }))

                # ‚îÄ‚îÄ stop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                elif accion == "stop":
                    if estado["state"] == "running":
                        cancelar_procesamiento = True
                        estado["state"] = "stopping"
                        await broadcast({"type": "status", "data": estado})

                # ‚îÄ‚îÄ get_status ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                elif accion == "get_status":
                    await websocket.send(json.dumps({"type": "status", "data": estado}))

                # ‚îÄ‚îÄ ping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                elif accion == "ping":
                    await websocket.send(json.dumps({"type": "pong"}))

            except json.JSONDecodeError:
                pass

    except ConnectionClosed:
        pass
    except Exception as e:
        print(f"Error con cliente {ip}: {e}")
    finally:
        clientes.discard(websocket)
        print(f"[{datetime.now().strftime('%H:%M:%S')}]  üîå  Cliente desconectado: {ip}")


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Punto de entrada
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def main():
    HOST = "localhost"
    PORT = 8765

    print("\n" + "=" * 60)
    print("  üöÄ  VERSI√ìN 4 - SERVIDOR WEBSOCKET")
    print("=" * 60)
    print(f"  üìÖ  {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"  üñ•Ô∏è   N√∫cleos detectados : {multiprocessing.cpu_count()}")
    print(f"  üåê  WebSocket          : ws://{HOST}:{PORT}")
    print(f"  üñºÔ∏è   Pillow             : {'‚úÖ Disponible' if PILLOW_DISPONIBLE else '‚ùå pip install Pillow'}")
    print(f"  üìä  psutil             : {'‚úÖ Disponible' if PSUTIL_DISPONIBLE else '‚ùå pip install psutil'}")
    print("=" * 60)
    print(f"\n  üìÇ  Abre en tu navegador:")
    print(f"      {Path(__file__).parent / 'frontend' / 'index.html'}")
    print(f"\n  ‚èπÔ∏è   Ctrl+C para detener\n")

    # Inicializar psutil (primera muestra siempre es 0)
    if PSUTIL_DISPONIBLE:
        psutil.cpu_percent(interval=None, percpu=True)

    async with websockets.serve(manejar_cliente, HOST, PORT):
        print(f"  ‚úÖ  Servidor escuchando en ws://{HOST}:{PORT}\n")
        asyncio.create_task(tarea_monitor_cpu())
        await asyncio.Future()   # Mantener el servidor activo indefinidamente


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\n  üõë  Servidor detenido\n")

```
**version3_paralelo.py**
```python
"""
VERSI√ìN 3 - PROCESAMIENTO PARALELO DE IM√ÅGENES (MULTIN√öCLEO)
=============================================================
Este programa procesa m√∫ltiples im√°genes de forma PARALELA
aplicando filtros y transformaciones.

Tarea: Aplicar filtros (blur, escala de grises) y redimensionamiento
Ahora usando multiprocessing para aprovechar el multin√∫cleo.

Requiere: pip install Pillow
"""

import time
import os
import multiprocessing
from datetime import datetime
from pathlib import Path
from PIL import Image, ImageFilter
import sys


def verificar_pillow():
    """
    Verifica que Pillow est√© instalado.
    """
    try:
        import PIL
        return True
    except ImportError:
        print("\n‚ùå ERROR: La biblioteca Pillow no est√° instalada.")
        print("\nüì¶ Para instalar Pillow, ejecuta:")
        print("   pip install Pillow")
        print("\nO si usas conda:")
        print("   conda install pillow")
        return False


def aplicar_blur(imagen):
    """
    Aplica filtro de desenfoque a una imagen.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con filtro blur aplicado
    """
    return imagen.filter(ImageFilter.GaussianBlur(radius=5))


def aplicar_escala_grises(imagen):
    """
    Convierte una imagen a escala de grises.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen en escala de grises
    """
    return imagen.convert('L')


def aplicar_blur_intenso(imagen):
    """
    Aplica filtro de desenfoque intenso.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con blur intenso
    """
    return imagen.filter(ImageFilter.GaussianBlur(radius=10))


def aplicar_sharpen(imagen):
    """
    Aplica filtro de nitidez a una imagen.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con filtro sharpen aplicado
    """
    return imagen.filter(ImageFilter.SHARPEN)


def aplicar_contorno(imagen):
    """
    Aplica filtro de detecci√≥n de contornos.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con contornos detectados
    """
    return imagen.filter(ImageFilter.FIND_EDGES)


def redimensionar(imagen, ancho, alto):
    """
    Redimensiona una imagen.
    
    Args:
        imagen: Objeto PIL Image
        ancho: Nuevo ancho
        alto: Nuevo alto
    
    Returns:
        Imagen redimensionada
    """
    return imagen.resize((ancho, alto), Image.Resampling.LANCZOS)


def procesar_imagen_wrapper(args):
    """
    Wrapper para procesar una imagen (necesario para multiprocessing).
    
    Args:
        args: Tupla (ruta_entrada, ruta_salida, operaciones)
    
    Returns:
        Diccionario con informaci√≥n del procesamiento
    """
    ruta_entrada, ruta_salida, operaciones = args
    return procesar_imagen(ruta_entrada, ruta_salida, operaciones)


def procesar_imagen(ruta_entrada, ruta_salida, operaciones):
    """
    Procesa una imagen aplicando las operaciones especificadas.
    Esta funci√≥n ser√° ejecutada en PARALELO por diferentes procesos.
    
    Args:
        ruta_entrada: Ruta de la imagen original
        ruta_salida: Ruta donde guardar la imagen procesada
        operaciones: Lista de operaciones a aplicar
    
    Returns:
        Diccionario con informaci√≥n del procesamiento
    """
    inicio = time.time()
    nombre_archivo = os.path.basename(ruta_entrada)
    proceso_id = multiprocessing.current_process().name
    
    print(f"  üîÑ [{proceso_id}] Procesando: {nombre_archivo}")
    
    try:
        # Cargar imagen
        imagen = Image.open(ruta_entrada)
        tamanio_original = imagen.size
        formato_original = imagen.format
        modo_original = imagen.mode
        
        # Aplicar operaciones
        ops_aplicadas = []
        for operacion in operaciones:
            if operacion['tipo'] == 'blur':
                imagen = aplicar_blur(imagen)
                ops_aplicadas.append('Blur')
            
            elif operacion['tipo'] == 'blur_intenso':
                imagen = aplicar_blur_intenso(imagen)
                ops_aplicadas.append('Blur Intenso')
            
            elif operacion['tipo'] == 'escala_grises':
                imagen = aplicar_escala_grises(imagen)
                ops_aplicadas.append('Escala de Grises')
            
            elif operacion['tipo'] == 'sharpen':
                imagen = aplicar_sharpen(imagen)
                ops_aplicadas.append('Sharpen')
            
            elif operacion['tipo'] == 'contorno':
                imagen = aplicar_contorno(imagen)
                ops_aplicadas.append('Detecci√≥n de Contornos')
            
            elif operacion['tipo'] == 'redimensionar':
                ancho = operacion.get('ancho', 800)
                alto = operacion.get('alto', 600)
                imagen = redimensionar(imagen, ancho, alto)
                ops_aplicadas.append(f'Redimensionar {ancho}x{alto}')
        
        # Guardar imagen procesada
        imagen.save(ruta_salida, quality=95)
        
        tiempo = time.time() - inicio
        tamanio_final = imagen.size
        
        # Obtener tama√±os de archivo
        tamanio_archivo_entrada = os.path.getsize(ruta_entrada) / 1024
        tamanio_archivo_salida = os.path.getsize(ruta_salida) / 1024
        
        # Mostrar resultado inmediatamente
        print(f"  ‚úÖ [{proceso_id}] {nombre_archivo}: "
              f"{tamanio_original} ‚Üí {tamanio_final} | "
              f"{tamanio_archivo_entrada:.2f} KB ‚Üí {tamanio_archivo_salida:.2f} KB | "
              f"{tiempo:.3f}s")
        
        return {
            'archivo': nombre_archivo,
            'ruta_entrada': ruta_entrada,
            'ruta_salida': ruta_salida,
            'exito': True,
            'tamanio_original': tamanio_original,
            'tamanio_final': tamanio_final,
            'formato': formato_original,
            'modo_original': modo_original,
            'operaciones_aplicadas': ops_aplicadas,
            'num_operaciones': len(ops_aplicadas),
            'tamanio_kb_entrada': round(tamanio_archivo_entrada, 2),
            'tamanio_kb_salida': round(tamanio_archivo_salida, 2),
            'tiempo_proceso': tiempo,
            'proceso': proceso_id
        }
    
    except FileNotFoundError:
        print(f"  ‚ùå [{proceso_id}] Error: Archivo no encontrado - {nombre_archivo}")
        return {
            'archivo': nombre_archivo,
            'ruta_entrada': ruta_entrada,
            'exito': False,
            'error': 'Archivo no encontrado',
            'tiempo_proceso': time.time() - inicio,
            'proceso': proceso_id
        }
    
    except Exception as e:
        print(f"  ‚ùå [{proceso_id}] Error: {str(e)} - {nombre_archivo}")
        return {
            'archivo': nombre_archivo,
            'ruta_entrada': ruta_entrada,
            'exito': False,
            'error': str(e),
            'tiempo_proceso': time.time() - inicio,
            'proceso': proceso_id
        }


def procesar_imagenes_paralelo(lista_imagenes, carpeta_salida, operaciones, num_procesos=None):
    """
    Procesa una lista de im√°genes de forma PARALELA.
    Distribuye las im√°genes entre todos los n√∫cleos disponibles.
    
    Args:
        lista_imagenes: Lista de rutas de im√°genes a procesar
        carpeta_salida: Carpeta donde guardar las im√°genes procesadas
        operaciones: Lista de operaciones a aplicar a cada imagen
        num_procesos: N√∫mero de procesos a usar (None = todos los n√∫cleos)
    
    Returns:
        Tupla (lista de resultados, tiempo total)
    """
    if num_procesos is None:
        num_procesos = multiprocessing.cpu_count()
    
    print("\n" + "="*70)
    print("üöÄ INICIANDO PROCESAMIENTO PARALELO DE IM√ÅGENES")
    print("="*70)
    print(f"üìä Im√°genes a procesar: {len(lista_imagenes)}")
    print(f"üñ•Ô∏è  N√∫cleos disponibles: {multiprocessing.cpu_count()}")
    print(f"‚öôÔ∏è  Procesos a usar: {num_procesos}")
    print(f"üé® Operaciones: {', '.join([op['tipo'] for op in operaciones])}")
    print("="*70 + "\n")
    
    inicio_total = time.time()
    
    # Preparar argumentos para cada imagen
    tareas = []
    for ruta_imagen in lista_imagenes:
        nombre_archivo = os.path.basename(ruta_imagen)
        nombre_sin_ext = os.path.splitext(nombre_archivo)[0]
        extension = os.path.splitext(nombre_archivo)[1]
        nombre_salida = f"{nombre_sin_ext}_procesado{extension}"
        ruta_salida = os.path.join(carpeta_salida, nombre_salida)
        
        tareas.append((ruta_imagen, ruta_salida, operaciones))
    
    # Crear pool de procesos y distribuir trabajo
    with multiprocessing.Pool(processes=num_procesos) as pool:
        resultados = pool.map(procesar_imagen_wrapper, tareas)
    
    tiempo_total = time.time() - inicio_total
    
    # Mostrar resumen
    print("\n" + "="*70)
    print("üìà RESUMEN DEL PROCESAMIENTO PARALELO")
    print("="*70)
    
    imagenes_exitosas = [r for r in resultados if r['exito']]
    
    if imagenes_exitosas:
        print(f"‚úÖ Im√°genes procesadas exitosamente: {len(imagenes_exitosas)}/{len(lista_imagenes)}")
        total_ops = sum(r['num_operaciones'] for r in imagenes_exitosas)
        print(f"üé® Total de operaciones aplicadas: {total_ops}")
        
        tamanio_total_entrada = sum(r['tamanio_kb_entrada'] for r in imagenes_exitosas)
        tamanio_total_salida = sum(r['tamanio_kb_salida'] for r in imagenes_exitosas)
        print(f"üíæ Tama√±o total entrada: {tamanio_total_entrada:.2f} KB")
        print(f"üíæ Tama√±o total salida: {tamanio_total_salida:.2f} KB")
    
    print(f"‚è±Ô∏è  Tiempo total: {tiempo_total:.2f} segundos")
    print(f"‚ö° Promedio por imagen: {tiempo_total/len(lista_imagenes):.2f} segundos")
    
    # Calcular speedup te√≥rico
    tiempo_proceso_total = sum(r['tiempo_proceso'] for r in resultados)
    print(f"üî• Speedup estimado: {tiempo_proceso_total/tiempo_total:.2f}x")
    print("="*70 + "\n")
    
    return resultados, tiempo_total


def main():
    """
    Funci√≥n principal del programa.
    """
    print("\n" + "="*70)
    print("üöÄ VERSI√ìN 3 - PROCESAMIENTO PARALELO DE IM√ÅGENES")
    print("="*70)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*70)
    
    # Verificar que Pillow est√© instalado
    if not verificar_pillow():
        return
    
    # Definir carpetas
    carpeta_entrada = Path(__file__).parent / "imagenes_entrada"
    carpeta_salida = Path(__file__).parent / "imagenes_salida"
    
    # Crear carpetas si no existen
    if not carpeta_entrada.exists():
        print(f"\n‚ö†Ô∏è  La carpeta 'imagenes_entrada' no existe.")
        print(f"üìÅ Creando carpeta: {carpeta_entrada}")
        carpeta_entrada.mkdir(exist_ok=True)
        print("‚ÑπÔ∏è  Por favor, coloca archivos de imagen en la carpeta 'imagenes_entrada' y ejecuta nuevamente.")
        print("üì∏ Formatos soportados: .jpg, .jpeg, .png, .bmp, .gif")
        return
    
    carpeta_salida.mkdir(exist_ok=True)
    
    # Buscar im√°genes
    extensiones = ['*.jpg', '*.jpeg', '*.png', '*.bmp', '*.gif']
    imagenes = []
    for ext in extensiones:
        imagenes.extend(list(carpeta_entrada.glob(ext)))
        imagenes.extend(list(carpeta_entrada.glob(ext.upper())))
    
    if not imagenes:
        print(f"\n‚ö†Ô∏è  No se encontraron im√°genes en '{carpeta_entrada}'")
        print("‚ÑπÔ∏è  Por favor, coloca archivos de imagen en la carpeta y ejecuta nuevamente.")
        print("üì∏ Formatos soportados: .jpg, .jpeg, .png, .bmp, .gif")
        return
    
    imagenes = [str(img) for img in imagenes]
    
    print(f"\nüìÇ Im√°genes encontradas: {len(imagenes)}")
    for imagen in imagenes:
        tamanio_kb = os.path.getsize(imagen) / 1024
        print(f"   - {os.path.basename(imagen)} ({tamanio_kb:.2f} KB)")
    
    # Definir operaciones a aplicar
    print(f"\nüé® Selecciona las operaciones a aplicar:")
    print("   1. Blur (desenfoque)")
    print("   2. Escala de grises")
    print("   3. Redimensionar a 800x600")
    print("   4. Sharpen (nitidez)")
    print("   5. Detecci√≥n de contornos")
    print("   6. Combo: Blur + Escala de grises + Redimensionar")
    print("   7. Todas las operaciones")
    
    try:
        opcion = input("\nIngresa el n√∫mero de opci√≥n (default: 6): ").strip()
        if not opcion:
            opcion = "6"
        opcion = int(opcion)
    except:
        opcion = 6
    
    # Configurar operaciones seg√∫n la opci√≥n
    if opcion == 1:
        operaciones = [{'tipo': 'blur'}]
    elif opcion == 2:
        operaciones = [{'tipo': 'escala_grises'}]
    elif opcion == 3:
        operaciones = [{'tipo': 'redimensionar', 'ancho': 800, 'alto': 600}]
    elif opcion == 4:
        operaciones = [{'tipo': 'sharpen'}]
    elif opcion == 5:
        operaciones = [{'tipo': 'contorno'}]
    elif opcion == 6:
        operaciones = [
            {'tipo': 'blur'},
            {'tipo': 'escala_grises'},
            {'tipo': 'redimensionar', 'ancho': 800, 'alto': 600}
        ]
    else:  # opcion 7
        operaciones = [
            {'tipo': 'blur'},
            {'tipo': 'escala_grises'},
            {'tipo': 'sharpen'},
            {'tipo': 'redimensionar', 'ancho': 800, 'alto': 600}
        ]
    
    # Procesar im√°genes
    resultados, tiempo_total = procesar_imagenes_paralelo(imagenes, str(carpeta_salida), operaciones)
    
    # Mostrar detalles
    print("\n" + "="*70)
    print("üìä DETALLES POR IMAGEN")
    print("="*70)
    
    for resultado in resultados:
        if resultado['exito']:
            print(f"\nüñºÔ∏è  {resultado['archivo']} (Proceso: {resultado['proceso']})")
            print(f"   - Tama√±o original: {resultado['tamanio_original']}")
            print(f"   - Tama√±o final: {resultado['tamanio_final']}")
            print(f"   - Formato: {resultado['formato']}")
            print(f"   - Operaciones aplicadas: {', '.join(resultado['operaciones_aplicadas'])}")
            print(f"   - Archivo entrada: {resultado['tamanio_kb_entrada']} KB")
            print(f"   - Archivo salida: {resultado['tamanio_kb_salida']} KB")
            print(f"   - Tiempo: {resultado['tiempo_proceso']:.3f}s")
            print(f"   - Guardado en: {os.path.basename(resultado['ruta_salida'])}")
    
    print(f"\nüìÅ Im√°genes procesadas guardadas en: {carpeta_salida}")
    print("\n" + "="*70)
    print("‚úÖ PROCESAMIENTO COMPLETADO")
    print("="*70 + "\n")


if __name__ == "__main__":
    main()

```
**version3_secuencial.py**
```python
"""
VERSI√ìN 3 - PROCESAMIENTO SECUENCIAL DE IM√ÅGENES
=================================================
Este programa procesa m√∫ltiples im√°genes de forma SECUENCIAL
aplicando filtros y transformaciones.

Tarea: Aplicar filtros (blur, escala de grises) y redimensionamiento
Procesa una imagen tras otra en un solo n√∫cleo del procesador.

Requiere: pip install Pillow
"""

import time
import os
from datetime import datetime
from pathlib import Path
from PIL import Image, ImageFilter
import sys


def verificar_pillow():
    """
    Verifica que Pillow est√© instalado.
    """
    try:
        import PIL
        return True
    except ImportError:
        print("\n‚ùå ERROR: La biblioteca Pillow no est√° instalada.")
        print("\nüì¶ Para instalar Pillow, ejecuta:")
        print("   pip install Pillow")
        print("\nO si usas conda:")
        print("   conda install pillow")
        return False


def aplicar_blur(imagen):
    """
    Aplica filtro de desenfoque a una imagen.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con filtro blur aplicado
    """
    return imagen.filter(ImageFilter.GaussianBlur(radius=5))


def aplicar_escala_grises(imagen):
    """
    Convierte una imagen a escala de grises.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen en escala de grises
    """
    return imagen.convert('L')


def aplicar_blur_intenso(imagen):
    """
    Aplica filtro de desenfoque intenso.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con blur intenso
    """
    return imagen.filter(ImageFilter.GaussianBlur(radius=10))


def aplicar_sharpen(imagen):
    """
    Aplica filtro de nitidez a una imagen.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con filtro sharpen aplicado
    """
    return imagen.filter(ImageFilter.SHARPEN)


def aplicar_contorno(imagen):
    """
    Aplica filtro de detecci√≥n de contornos.
    
    Args:
        imagen: Objeto PIL Image
    
    Returns:
        Imagen con contornos detectados
    """
    return imagen.filter(ImageFilter.FIND_EDGES)


def redimensionar(imagen, ancho, alto):
    """
    Redimensiona una imagen.
    
    Args:
        imagen: Objeto PIL Image
        ancho: Nuevo ancho
        alto: Nuevo alto
    
    Returns:
        Imagen redimensionada
    """
    return imagen.resize((ancho, alto), Image.Resampling.LANCZOS)


def procesar_imagen(ruta_entrada, ruta_salida, operaciones):
    """
    Procesa una imagen aplicando las operaciones especificadas.
    
    Args:
        ruta_entrada: Ruta de la imagen original
        ruta_salida: Ruta donde guardar la imagen procesada
        operaciones: Lista de operaciones a aplicar
    
    Returns:
        Diccionario con informaci√≥n del procesamiento
    """
    inicio = time.time()
    nombre_archivo = os.path.basename(ruta_entrada)
    
    try:
        # Cargar imagen
        imagen = Image.open(ruta_entrada)
        tamanio_original = imagen.size
        formato_original = imagen.format
        modo_original = imagen.mode
        
        # Aplicar operaciones
        ops_aplicadas = []
        for operacion in operaciones:
            if operacion['tipo'] == 'blur':
                imagen = aplicar_blur(imagen)
                ops_aplicadas.append('Blur')
            
            elif operacion['tipo'] == 'blur_intenso':
                imagen = aplicar_blur_intenso(imagen)
                ops_aplicadas.append('Blur Intenso')
            
            elif operacion['tipo'] == 'escala_grises':
                imagen = aplicar_escala_grises(imagen)
                ops_aplicadas.append('Escala de Grises')
            
            elif operacion['tipo'] == 'sharpen':
                imagen = aplicar_sharpen(imagen)
                ops_aplicadas.append('Sharpen')
            
            elif operacion['tipo'] == 'contorno':
                imagen = aplicar_contorno(imagen)
                ops_aplicadas.append('Detecci√≥n de Contornos')
            
            elif operacion['tipo'] == 'redimensionar':
                ancho = operacion.get('ancho', 800)
                alto = operacion.get('alto', 600)
                imagen = redimensionar(imagen, ancho, alto)
                ops_aplicadas.append(f'Redimensionar {ancho}x{alto}')
        
        # Guardar imagen procesada
        imagen.save(ruta_salida, quality=95)
        
        tiempo = time.time() - inicio
        tamanio_final = imagen.size
        
        # Obtener tama√±os de archivo
        tamanio_archivo_entrada = os.path.getsize(ruta_entrada) / 1024
        tamanio_archivo_salida = os.path.getsize(ruta_salida) / 1024
        
        return {
            'archivo': nombre_archivo,
            'ruta_entrada': ruta_entrada,
            'ruta_salida': ruta_salida,
            'exito': True,
            'tamanio_original': tamanio_original,
            'tamanio_final': tamanio_final,
            'formato': formato_original,
            'modo_original': modo_original,
            'operaciones_aplicadas': ops_aplicadas,
            'num_operaciones': len(ops_aplicadas),
            'tamanio_kb_entrada': round(tamanio_archivo_entrada, 2),
            'tamanio_kb_salida': round(tamanio_archivo_salida, 2),
            'tiempo_proceso': tiempo
        }
    
    except FileNotFoundError:
        return {
            'archivo': nombre_archivo,
            'ruta_entrada': ruta_entrada,
            'exito': False,
            'error': 'Archivo no encontrado',
            'tiempo_proceso': time.time() - inicio
        }
    
    except Exception as e:
        return {
            'archivo': nombre_archivo,
            'ruta_entrada': ruta_entrada,
            'exito': False,
            'error': str(e),
            'tiempo_proceso': time.time() - inicio
        }


def procesar_imagenes_secuencial(lista_imagenes, carpeta_salida, operaciones):
    """
    Procesa una lista de im√°genes de forma SECUENCIAL.
    Cada imagen se procesa una despu√©s de la otra.
    
    Args:
        lista_imagenes: Lista de rutas de im√°genes a procesar
        carpeta_salida: Carpeta donde guardar las im√°genes procesadas
        operaciones: Lista de operaciones a aplicar a cada imagen
    
    Returns:
        Tupla (lista de resultados, tiempo total)
    """
    print("\n" + "="*70)
    print("üñºÔ∏è  INICIANDO PROCESAMIENTO SECUENCIAL DE IM√ÅGENES")
    print("="*70)
    print(f"üìä Im√°genes a procesar: {len(lista_imagenes)}")
    print(f"üñ•Ô∏è  Modo: UN SOLO N√öCLEO (secuencial)")
    print(f"üé® Operaciones: {', '.join([op['tipo'] for op in operaciones])}")
    print("="*70 + "\n")
    
    inicio_total = time.time()
    resultados = []
    
    # Procesar cada imagen secuencialmente
    for i, ruta_imagen in enumerate(lista_imagenes, 1):
        nombre_archivo = os.path.basename(ruta_imagen)
        print(f"üîÑ Procesando imagen {i}/{len(lista_imagenes)}: {nombre_archivo}")
        
        # Generar ruta de salida
        nombre_sin_ext = os.path.splitext(nombre_archivo)[0]
        extension = os.path.splitext(nombre_archivo)[1]
        nombre_salida = f"{nombre_sin_ext}_procesado{extension}"
        ruta_salida = os.path.join(carpeta_salida, nombre_salida)
        
        # Procesar imagen
        resultado = procesar_imagen(ruta_imagen, ruta_salida, operaciones)
        resultados.append(resultado)
        
        if resultado['exito']:
            print(f"  ‚úÖ {resultado['tamanio_original']} ‚Üí {resultado['tamanio_final']} | "
                  f"{resultado['tamanio_kb_entrada']} KB ‚Üí {resultado['tamanio_kb_salida']} KB | "
                  f"{resultado['tiempo_proceso']:.3f}s\n")
        else:
            print(f"  ‚ùå Error: {resultado['error']}\n")
    
    tiempo_total = time.time() - inicio_total
    
    # Mostrar resumen
    print("="*70)
    print("üìà RESUMEN DEL PROCESAMIENTO SECUENCIAL")
    print("="*70)
    
    imagenes_exitosas = [r for r in resultados if r['exito']]
    
    if imagenes_exitosas:
        print(f"‚úÖ Im√°genes procesadas exitosamente: {len(imagenes_exitosas)}/{len(lista_imagenes)}")
        total_ops = sum(r['num_operaciones'] for r in imagenes_exitosas)
        print(f"üé® Total de operaciones aplicadas: {total_ops}")
        
        tamanio_total_entrada = sum(r['tamanio_kb_entrada'] for r in imagenes_exitosas)
        tamanio_total_salida = sum(r['tamanio_kb_salida'] for r in imagenes_exitosas)
        print(f"üíæ Tama√±o total entrada: {tamanio_total_entrada:.2f} KB")
        print(f"üíæ Tama√±o total salida: {tamanio_total_salida:.2f} KB")
    
    print(f"‚è±Ô∏è  Tiempo total: {tiempo_total:.2f} segundos")
    print(f"‚ö° Promedio por imagen: {tiempo_total/len(lista_imagenes):.2f} segundos")
    print("="*70 + "\n")
    
    return resultados, tiempo_total


def main():
    """
    Funci√≥n principal del programa.
    """
    print("\n" + "="*70)
    print("üöÄ VERSI√ìN 3 - PROCESAMIENTO SECUENCIAL DE IM√ÅGENES")
    print("="*70)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*70)
    
    # Verificar que Pillow est√© instalado
    if not verificar_pillow():
        return
    
    # Definir carpetas
    carpeta_entrada = Path(__file__).parent / "imagenes_entrada"
    carpeta_salida = Path(__file__).parent / "imagenes_salida"
    
    # Crear carpetas si no existen
    if not carpeta_entrada.exists():
        print(f"\n‚ö†Ô∏è  La carpeta 'imagenes_entrada' no existe.")
        print(f"üìÅ Creando carpeta: {carpeta_entrada}")
        carpeta_entrada.mkdir(exist_ok=True)
        print("‚ÑπÔ∏è  Por favor, coloca archivos de imagen en la carpeta 'imagenes_entrada' y ejecuta nuevamente.")
        print("üì∏ Formatos soportados: .jpg, .jpeg, .png, .bmp, .gif")
        return
    
    carpeta_salida.mkdir(exist_ok=True)
    
    # Buscar im√°genes
    extensiones = ['*.jpg', '*.jpeg', '*.png', '*.bmp', '*.gif']
    imagenes = []
    for ext in extensiones:
        imagenes.extend(list(carpeta_entrada.glob(ext)))
        imagenes.extend(list(carpeta_entrada.glob(ext.upper())))
    
    if not imagenes:
        print(f"\n‚ö†Ô∏è  No se encontraron im√°genes en '{carpeta_entrada}'")
        print("‚ÑπÔ∏è  Por favor, coloca archivos de imagen en la carpeta y ejecuta nuevamente.")
        print("üì∏ Formatos soportados: .jpg, .jpeg, .png, .bmp, .gif")
        return
    
    imagenes = [str(img) for img in imagenes]
    
    print(f"\nüìÇ Im√°genes encontradas: {len(imagenes)}")
    for imagen in imagenes:
        tamanio_kb = os.path.getsize(imagen) / 1024
        print(f"   - {os.path.basename(imagen)} ({tamanio_kb:.2f} KB)")
    
    # Definir operaciones a aplicar
    print(f"\nüé® Selecciona las operaciones a aplicar:")
    print("   1. Blur (desenfoque)")
    print("   2. Escala de grises")
    print("   3. Redimensionar a 800x600")
    print("   4. Sharpen (nitidez)")
    print("   5. Detecci√≥n de contornos")
    print("   6. Combo: Blur + Escala de grises + Redimensionar")
    print("   7. Todas las operaciones")
    
    try:
        opcion = input("\nIngresa el n√∫mero de opci√≥n (default: 6): ").strip()
        if not opcion:
            opcion = "6"
        opcion = int(opcion)
    except:
        opcion = 6
    
    # Configurar operaciones seg√∫n la opci√≥n
    if opcion == 1:
        operaciones = [{'tipo': 'blur'}]
    elif opcion == 2:
        operaciones = [{'tipo': 'escala_grises'}]
    elif opcion == 3:
        operaciones = [{'tipo': 'redimensionar', 'ancho': 800, 'alto': 600}]
    elif opcion == 4:
        operaciones = [{'tipo': 'sharpen'}]
    elif opcion == 5:
        operaciones = [{'tipo': 'contorno'}]
    elif opcion == 6:
        operaciones = [
            {'tipo': 'blur'},
            {'tipo': 'escala_grises'},
            {'tipo': 'redimensionar', 'ancho': 800, 'alto': 600}
        ]
    else:  # opcion 7
        operaciones = [
            {'tipo': 'blur'},
            {'tipo': 'escala_grises'},
            {'tipo': 'sharpen'},
            {'tipo': 'redimensionar', 'ancho': 800, 'alto': 600}
        ]
    
    # Procesar im√°genes
    resultados, tiempo_total = procesar_imagenes_secuencial(imagenes, str(carpeta_salida), operaciones)
    
    # Mostrar detalles
    print("\n" + "="*70)
    print("üìä DETALLES POR IMAGEN")
    print("="*70)
    
    for resultado in resultados:
        if resultado['exito']:
            print(f"\nüñºÔ∏è  {resultado['archivo']}")
            print(f"   - Tama√±o original: {resultado['tamanio_original']}")
            print(f"   - Tama√±o final: {resultado['tamanio_final']}")
            print(f"   - Formato: {resultado['formato']}")
            print(f"   - Operaciones aplicadas: {', '.join(resultado['operaciones_aplicadas'])}")
            print(f"   - Archivo entrada: {resultado['tamanio_kb_entrada']} KB")
            print(f"   - Archivo salida: {resultado['tamanio_kb_salida']} KB")
            print(f"   - Tiempo: {resultado['tiempo_proceso']:.3f}s")
            print(f"   - Guardado en: {os.path.basename(resultado['ruta_salida'])}")
    
    print(f"\nüìÅ Im√°genes procesadas guardadas en: {carpeta_salida}")
    print("\n" + "="*70)
    print("‚úÖ PROCESAMIENTO COMPLETADO")
    print("="*70 + "\n")


if __name__ == "__main__":
    main()

```
## datos_ejemplo
**README.md**
```markdown
# üìÅ Datos de Ejemplo

Esta carpeta contiene archivos de texto de ejemplo para probar el procesamiento paralelo de archivos de la **Versi√≥n 2.0**.

## üìÑ Archivos Incluidos

Los archivos de ejemplo incluyen art√≠culos informativos sobre diferentes temas relacionados con programaci√≥n y procesamiento paralelo:

1. **articulo1_procesamiento_paralelo.txt** - Introducci√≥n al procesamiento paralelo en Python
2. **articulo2_multicore.txt** - Programaci√≥n multin√∫cleo y sus conceptos
3. **articulo3_python.txt** - El lenguaje Python y sus caracter√≠sticas
4. **articulo4_analisis_texto.txt** - An√°lisis de texto con Python
5. **articulo5_optimizacion.txt** - Optimizaci√≥n de c√≥digo Python

## üéØ Prop√≥sito

Estos archivos permiten:
- ‚úÖ Probar el procesamiento secuencial y paralelo
- ‚úÖ Ver las diferencias de rendimiento
- ‚úÖ Analizar estad√≠sticas de texto reales
- ‚úÖ Comparar resultados entre ambos m√©todos

## üöÄ Uso

Los scripts `version2_secuencial.py` y `version2_paralelo.py` buscan autom√°ticamente archivos `.txt` en esta carpeta.

Simplemente ejecuta:
```powershell
python version2_secuencial.py
# o
python version2_paralelo.py
```

## ‚ûï Agregar M√°s Archivos

Puedes agregar tus propios archivos `.txt` a esta carpeta para procesarlos. Los scripts detectar√°n autom√°ticamente todos los archivos `.txt` disponibles.

**Recomendaciones:**
- Usa codificaci√≥n UTF-8 para los archivos
- Los archivos m√°s grandes mostrar√°n mejores diferencias de rendimiento
- Prueba con diferentes cantidades de archivos para ver el impacto del paralelismo

```
## frontend
**app.js**
```js
/**
 * VERSI√ìN 4 ‚Äî DASHBOARD MULTIN√öCLEO
 * L√≥gica del cliente WebSocket en tiempo real
 *
 * Flujo:
 *  1. Intenta conectar al servidor ws://localhost:8765
 *  2. Recibe mensajes JSON y actualiza la UI
 *  3. Env√≠a comandos (start / stop) al servidor
 */

"use strict";

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   CONFIGURACI√ìN
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const WS_URL        = "ws://localhost:8765";
const RECONECT_DELAY = 3000;   // ms entre intentos de reconexi√≥n

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   REFERENCIAS AL DOM
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const $ = id => document.getElementById(id);

const DOM = {
  connDot:          $("connDot"),
  connLabel:        $("connLabel"),
  stateBadge:       $("stateBadge"),

  // Sistema info
  sysCores:         $("sysCores"),
  sysPillow:        $("sysPillow"),
  sysPsutil:        $("sysPsutil"),
  cpuTotal:         $("cpuTotal"),
  cpuTotalBar:      $("cpuTotalBar"),
  ramInfo:          $("ramInfo"),
  ramBar:           $("ramBar"),
  cpuGrid:          $("cpuGrid"),

  // M√©tricas
  mSpeedup:         $("mSpeedup"),
  mEfficiency:      $("mEfficiency"),
  mTime:            $("mTime"),
  mImages:          $("mImages"),

  // Progreso
  progressBar:      $("progressBar"),
  progressLabel:    $("progressLabel"),
  progressCounter:  $("progressCounter"),
  progressFile:     $("progressFile"),

  // Resultados
  resultsBody:      $("resultsBody"),

  // Log
  logBody:          $("logBody"),

  // Controles
  btnStart:         $("btnStart"),
  btnStop:          $("btnStop"),
  workerSlider:     $("workerSlider"),
  workerVal:        $("workerVal"),
  resizeSelect:     $("resizeSelect"),
  opBlur:           $("opBlur"),
  opGrises:         $("opGrises"),
  opResize:         $("opResize"),
  opSharpen:        $("opSharpen"),
  opContorno:       $("opContorno"),
  btnClearLog:      $("btnClearLog"),
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   ESTADO DE LA APLICACI√ìN
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let ws            = null;
let reconectTimer = null;
let coresCount    = 0;
let coresDOMReady = false;
let resultCount   = 0;
let serverState   = "idle";   // idle | running | stopping

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   WEBSOCKET
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function conectar() {
  addLog("üîå Conectando a " + WS_URL + "...", "info");
  setConnected(false);

  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    clearTimeout(reconectTimer);
    setConnected(true);
    ws.send(JSON.stringify({ action: "get_status" }));
  };

  ws.onmessage = e => {
    let msg;
    try   { msg = JSON.parse(e.data); }
    catch { return; }
    handleMessage(msg);
  };

  ws.onclose = () => {
    setConnected(false);
    addLog("‚ö†Ô∏è  Conexi√≥n cerrada. Reconectando en 3s...", "warning");
    reconectTimer = setTimeout(conectar, RECONECT_DELAY);
  };

  ws.onerror = () => {
    addLog("‚ùå Error de conexi√≥n ‚Äî ¬øest√° el servidor activo?", "error");
  };
}

function send(obj) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(obj));
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   MANEJADOR CENTRAL DE MENSAJES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function handleMessage(msg) {
  switch (msg.type) {

    case "cpu_stats":
      updateCPU(msg.data);
      break;

    case "log":
      addLog(msg.data.message, msg.data.level, msg.data.timestamp);
      break;

    case "progress":
      updateProgress(msg.data);
      break;

    case "result":
      addResult(msg.data);
      break;

    case "status":
      updateStatus(msg.data);
      break;

    case "metrics":
      updateMetrics(msg.data);
      break;

    case "pong":
      // Keep-alive
      break;
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   ACTUALIZAR UI
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

// ‚îÄ‚îÄ Conexi√≥n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setConnected(ok) {
  DOM.connDot.className   = "conn-dot" + (ok ? " connected" : "");
  DOM.connLabel.textContent = ok ? "Conectado" : "Desconectado";
  DOM.btnStart.disabled   = !ok || serverState === "running";
}

// ‚îÄ‚îÄ Status del servidor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateStatus(data) {
  serverState = data.state || "idle";

  // Badge de estado
  const labels = { idle: "Inactivo", running: "Procesando", stopping: "Deteniendo" };
  const badgeText = DOM.stateBadge.querySelector('.badge-text');
  if (badgeText) {
    badgeText.textContent = labels[serverState] || serverState;
  } else {
    DOM.stateBadge.textContent = labels[serverState] || serverState;
  }
  DOM.stateBadge.className    = "state-badge " + serverState;

  // Botones
  DOM.btnStart.disabled = serverState !== "idle";
  DOM.btnStop.disabled  = serverState !== "running";
  DOM.btnStart.className = serverState === "running"
    ? "btn btn-start running"
    : "btn btn-start";

  // Info del sistema (solo primera vez)
  if (data.cpu_count && !coresDOMReady) {
    DOM.sysCores.textContent = data.cpu_count + " n√∫cleos";
    DOM.workerSlider.max     = data.cpu_count;
    DOM.workerSlider.value   = data.cpu_count;
    DOM.workerVal.textContent = data.cpu_count;
    buildCoreCards(data.cpu_count);
  }

  const svgOK  = `<svg style="vertical-align:-2px;margin-right:4px" width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>`;
  const svgFail = `<svg style="vertical-align:-2px;margin-right:4px" width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;

  if (data.pillow !== undefined) {
    DOM.sysPillow.innerHTML   = data.pillow ? svgOK + "OK" : svgFail + "No";
    DOM.sysPillow.style.color = data.pillow ? "var(--green)" : "var(--red)";
  }

  if (data.psutil !== undefined) {
    DOM.sysPsutil.innerHTML   = data.psutil  ? svgOK + "OK" : svgFail + "No";
    DOM.sysPsutil.style.color = data.psutil  ? "var(--green)" : "var(--red)";
  }
}

// ‚îÄ‚îÄ CPU por n√∫cleo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function buildCoreCards(n) {
  coresCount   = n;
  coresDOMReady = true;
  DOM.cpuGrid.innerHTML = "";

  for (let i = 0; i < n; i++) {
    const card = document.createElement("div");
    card.className = "core-card";
    card.innerHTML = `
      <span class="core-label">Core ${i}</span>
      <div class="core-usage-bar">
        <div class="core-bar-fill low" id="coreBar${i}" style="height:0%"></div>
      </div>
      <span class="core-pct" id="corePct${i}">0%</span>
    `;
    DOM.cpuGrid.appendChild(card);
  }
}

function updateCPU(data) {
  const cores = data.cores || [];

  // Reconstruir grid si cambia el n√∫mero de n√∫cleos
  if (cores.length !== coresCount) {
    buildCoreCards(cores.length);
  }

  cores.forEach((pct, i) => {
    const bar  = $(`coreBar${i}`);
    const lbl  = $(`corePct${i}`);
    if (!bar || !lbl) return;

    bar.style.height = pct + "%";
    lbl.textContent  = pct + "%";

    // Color seg√∫n carga
    bar.className = "core-bar-fill " + (
      pct <  30 ? "low"    :
      pct <  60 ? "medium" :
      pct <  85 ? "high"   : "max"
    );
  });

  // CPU total
  const total = data.total || 0;
  DOM.cpuTotal.textContent = total + "%";
  DOM.cpuTotalBar.style.width = total + "%";

  // RAM
  if (data.ram_percent !== undefined) {
    DOM.ramInfo.textContent = `${data.ram_used_gb} / ${data.ram_total_gb} GB (${data.ram_percent}%)`;
    DOM.ramBar.style.width  = data.ram_percent + "%";

    // Color seg√∫n uso de RAM
    const rp = data.ram_percent;
    DOM.ramBar.style.background =
      rp < 60 ? "var(--purple)" :
      rp < 80 ? "var(--orange)" : "var(--red)";
  }
}

// ‚îÄ‚îÄ Progreso ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateProgress(data) {
  const pct     = data.percentage || 0;
  const current = data.current    || 0;
  const total   = data.total      || 0;

  DOM.progressBar.style.width    = pct + "%";
  DOM.progressLabel.textContent  = pct === 100
    ? "‚úÖ Completado"
    : `Procesando... ${pct}%`;
  DOM.progressCounter.textContent = `${current} / ${total}`;
  DOM.progressFile.textContent    = data.file
    ? "üìÑ " + data.file
    : "Esperando...";

  DOM.mImages.textContent = `${current} / ${total}`;
}

// ‚îÄ‚îÄ Resultado individual ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function addResult(data) {
  // Quitar fila de "Sin resultados" la primera vez
  if (resultCount === 0) {
    DOM.resultsBody.innerHTML = "";
  }
  resultCount++;

  // Construir tags HTML de operaciones
  const opTagMap = {
    "Blur":               "blur",
    "Blur Intenso":       "blur",
    "Escala de Grises":   "grises",
    "Sharpen":            "sharpen",
    "Detecci√≥n de Contornos": "contorno",
  };
  const tagsHTML = (data.operations || []).map(op => {
    const key = op.startsWith("Redimensionar") ? "resize" : (opTagMap[op] || "");
    const label = op.startsWith("Redimensionar") ? op : op;
    return `<span class="tag ${key}">${label}</span>`;
  }).join("");

  const workerNum = data.proceso
    ? data.proceso.replace("ForkPoolWorker-", "W").replace("SpawnPoolWorker-", "W")
    : "‚Äî";

  const tr = document.createElement("tr");
  tr.innerHTML = `
    <td title="${data.file}">${data.file}</td>
    <td>${tagsHTML}</td>
    <td>${data.size_before_kb} KB</td>
    <td>${data.size_after_kb} KB</td>
    <td style="font-family:var(--font-mono); color:var(--green)">${data.time}s</td>
    <td style="font-family:var(--font-mono); color:var(--blue)">${workerNum}</td>
  `;
  DOM.resultsBody.prepend(tr);   // m√°s reciente arriba
}

// ‚îÄ‚îÄ M√©tricas finales ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateMetrics(data) {
  DOM.mSpeedup.textContent    = data.speedup    + "√ó";
  DOM.mEfficiency.textContent = data.efficiency + "%";
  DOM.mTime.textContent       = data.total_time + "s";
  DOM.mImages.textContent     = `${data.successful} / ${data.total}`;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   LOG CONSOLE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function addLog(message, level = "info", ts = null) {
  const timestamp = ts || new Date().toLocaleTimeString("es-ES", { hour12: false });
  const entry = document.createElement("div");
  entry.className = `log-entry ${level}`;
  entry.innerHTML = `
    <span class="log-ts">${timestamp}</span>
    <span class="log-msg">${escapeHTML(message)}</span>
  `;
  DOM.logBody.appendChild(entry);
  DOM.logBody.scrollTop = DOM.logBody.scrollHeight;

  // Limitar a 200 entradas para no saturar el DOM
  while (DOM.logBody.children.length > 200) {
    DOM.logBody.removeChild(DOM.logBody.firstChild);
  }
}

function escapeHTML(str) {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   CONSTRUIR PAYLOAD DE OPERACIONES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function buildOperaciones() {
  const ops = [];

  if (DOM.opBlur.checked)     ops.push({ tipo: "blur" });
  if (DOM.opGrises.checked)   ops.push({ tipo: "escala_grises" });
  if (DOM.opSharpen.checked)  ops.push({ tipo: "sharpen" });
  if (DOM.opContorno.checked) ops.push({ tipo: "contorno" });

  if (DOM.opResize.checked) {
    const [w, h] = DOM.resizeSelect.value.split("x").map(Number);
    ops.push({ tipo: "redimensionar", ancho: w, alto: h });
  }

  // Al menos una operaci√≥n
  if (ops.length === 0) ops.push({ tipo: "blur" });
  return ops;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   EVENTOS DE CONTROLES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

// Slider de workers
DOM.workerSlider.addEventListener("input", () => {
  DOM.workerVal.textContent = DOM.workerSlider.value;
});

// Bot√≥n INICIAR
DOM.btnStart.addEventListener("click", () => {
  if (serverState !== "idle") return;

  // Resetear UI de resultados y progreso
  resultCount = 0;
  DOM.resultsBody.innerHTML = `
    <tr>
      <td colspan="6" style="color:var(--text-muted); text-align:center; padding:14px">
        Procesando im√°genes...
      </td>
    </tr>`;
  DOM.progressBar.style.width    = "0%";
  DOM.progressLabel.textContent  = "Iniciando...";
  DOM.progressCounter.textContent = "0 / 0";
  DOM.progressFile.textContent   = "";
  DOM.mSpeedup.textContent    = "‚Äî";
  DOM.mEfficiency.textContent = "‚Äî";
  DOM.mTime.textContent       = "‚Äî";
  DOM.mImages.textContent     = "0 / 0";

  send({
    action: "start",
    data: {
      operaciones: buildOperaciones(),
      num_workers: parseInt(DOM.workerSlider.value),
    }
  });
});

// Bot√≥n DETENER
DOM.btnStop.addEventListener("click", () => {
  if (serverState !== "running") return;
  send({ action: "stop" });
  addLog("üõë Solicitando detenci√≥n...", "warning");
});

// Limpiar log
DOM.btnClearLog.addEventListener("click", () => {
  DOM.logBody.innerHTML = "";
});

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   INICIO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
conectar();
```
**index.html**
```html
Ôªø<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>N-Core | Dashboard</title>
  <link rel="icon" type="image/png" href="https://static.agusmadev.es/logos/logo-morado-blanco.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

<!-- HEADER -->
<header>
  <div class="brand">
    <div class="brand-logo" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
      </svg>
    </div>
    <div class="brand-text">
      <span class="brand-name">N-Core</span>
      <span class="brand-sub">Procesamiento Multinucleo</span>
    </div>
    <span class="version-badge">v4.0</span>
  </div>

  <div class="header-right">
    <span id="stateBadge" class="state-badge idle">
      <span class="badge-dot"></span>
      <span class="badge-text">Inactivo</span>
    </span>
    <div class="conn-indicator">
      <span class="conn-dot" id="connDot"></span>
      <span id="connLabel">Desconectado</span>
    </div>
  </div>
</header>

<!-- LAYOUT -->
<div class="layout">

  <!-- SIDEBAR -->
  <aside class="sidebar">

    <div class="panel">
      <div class="panel-title">
        <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8M12 17v4"/></svg>
        Sistema
      </div>
      <div class="sys-info">
        <div class="sys-row">
          <span class="sys-key">Nucleos</span>
          <span class="sys-val" id="sysCores">&#8212;</span>
        </div>
        <div class="sys-row">
          <span class="sys-key">Pillow</span>
          <span class="sys-val" id="sysPillow">&#8212;</span>
        </div>
        <div class="sys-row">
          <span class="sys-key">psutil</span>
          <span class="sys-val" id="sysPsutil">&#8212;</span>
        </div>
        <div class="sys-divider"></div>
        <div class="sys-row sys-metric">
          <span class="sys-key">CPU Total</span>
          <span class="sys-val accent-blue" id="cpuTotal">0%</span>
        </div>
        <div class="mini-bar-track">
          <div class="mini-bar-fill blue" id="cpuTotalBar" style="width:0%"></div>
        </div>
        <div class="sys-row sys-metric" style="margin-top:10px">
          <span class="sys-key">RAM</span>
          <span class="sys-val accent-purple" id="ramInfo">&#8212;</span>
        </div>
        <div class="mini-bar-track">
          <div class="mini-bar-fill purple" id="ramBar" style="width:0%"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">
        <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.07 4.93a10 10 0 010 14.14M4.93 4.93a10 10 0 000 14.14"/></svg>
        Configuracion
      </div>

      <div class="control-group">
        <label class="control-label">Workers (procesos paralelos)</label>
        <div class="worker-row">
          <input type="range" id="workerSlider" min="1" max="16" value="4" />
          <span class="worker-val" id="workerVal">4</span>
        </div>
      </div>

      <div class="control-group">
        <label class="control-label">Tamano de redimension</label>
        <select id="resizeSelect">
          <option value="320x240">Pequeno &#8212; 320 x 240</option>
          <option value="640x480">Mediano &#8212; 640 x 480</option>
          <option value="800x600" selected>Estandar &#8212; 800 x 600</option>
          <option value="1280x720">HD &#8212; 1280 x 720</option>
          <option value="1920x1080">Full HD &#8212; 1920 x 1080</option>
        </select>
      </div>

      <div class="control-group">
        <label class="control-label">Operaciones a aplicar</label>
        <div class="op-list">
          <label class="op-item">
            <input type="checkbox" id="opBlur" checked />
            <span class="op-checkmark"></span>
            <span class="op-name">Blur</span>
            <span class="op-badge blur">filtro</span>
          </label>
          <label class="op-item">
            <input type="checkbox" id="opGrises" checked />
            <span class="op-checkmark"></span>
            <span class="op-name">Escala de Grises</span>
            <span class="op-badge grises">color</span>
          </label>
          <label class="op-item">
            <input type="checkbox" id="opResize" checked />
            <span class="op-checkmark"></span>
            <span class="op-name">Redimensionar</span>
            <span class="op-badge resize">batch</span>
          </label>
          <label class="op-item">
            <input type="checkbox" id="opSharpen" />
            <span class="op-checkmark"></span>
            <span class="op-name">Sharpen</span>
            <span class="op-badge sharpen">filtro</span>
          </label>
          <label class="op-item">
            <input type="checkbox" id="opContorno" />
            <span class="op-checkmark"></span>
            <span class="op-name">Contornos</span>
            <span class="op-badge contorno">analisis</span>
          </label>
        </div>
      </div>

      <div class="btn-group">
        <button class="btn btn-start" id="btnStart">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
          Iniciar Procesamiento
        </button>
        <button class="btn btn-stop" id="btnStop" disabled>
          <svg viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="1"/></svg>
          Detener
        </button>
      </div>
    </div>

  </aside>

  <!-- AREA PRINCIPAL -->
  <div class="main-area">

    <!-- Metricas -->
    <div class="metrics-row">
      <div class="metric-card green">
        <div class="metric-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>
        </div>
        <div class="metric-body">
          <div class="m-label">Speedup</div>
          <div class="m-value" id="mSpeedup">&#8212;</div>
          <div class="m-sub">vs. proceso secuencial</div>
        </div>
      </div>
      <div class="metric-card blue">
        <div class="metric-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>
        </div>
        <div class="metric-body">
          <div class="m-label">Eficiencia</div>
          <div class="m-value" id="mEfficiency">&#8212;</div>
          <div class="m-sub">uso promedio de nucleos</div>
        </div>
      </div>
      <div class="metric-card orange">
        <div class="metric-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
        </div>
        <div class="metric-body">
          <div class="m-label">Tiempo Total</div>
          <div class="m-value" id="mTime">&#8212;</div>
          <div class="m-sub">segundos de ejecucion</div>
        </div>
      </div>
      <div class="metric-card purple">
        <div class="metric-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
        </div>
        <div class="metric-body">
          <div class="m-label">Imagenes</div>
          <div class="m-value" id="mImages">0 / 0</div>
          <div class="m-sub">procesadas con exito</div>
        </div>
      </div>
    </div>

    <!-- Progreso -->
    <div class="panel">
      <div class="panel-title">
        <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="10" rx="2"/></svg>
        Progreso
        <span class="panel-title-spacer"></span>
        <span class="progress-counter-badge" id="progressCounter">0 / 0</span>
      </div>
      <div class="progress-section">
        <div class="progress-bar-track">
          <div class="progress-bar-fill" id="progressBar"></div>
        </div>
        <div class="progress-footer">
          <span class="progress-label" id="progressLabel">En espera...</span>
          <span class="progress-file" id="progressFile">Ningun archivo activo</span>
        </div>
      </div>
    </div>

    <!-- CPU por Nucleo -->
    <div class="panel">
      <div class="panel-title">
        <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1v3M15 1v3M9 20v3M15 20v3M1 9h3M1 15h3M20 9h3M20 15h3"/></svg>
        Uso de CPU por Nucleo
      </div>
      <div class="cpu-grid" id="cpuGrid">
        <div class="cpu-placeholder">
          Conectando al servidor&#8230;
        </div>
      </div>
    </div>

    <!-- Resultados + Logs -->
    <div class="bottom-area">

      <div class="panel panel-table">
        <div class="panel-title">
          <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
          Resultados por Imagen
        </div>
        <div class="results-scroll">
          <table class="results-table">
            <thead>
              <tr>
                <th>Archivo</th>
                <th>Operaciones</th>
                <th>Antes</th>
                <th>Despues</th>
                <th>Tiempo</th>
                <th>Worker</th>
              </tr>
            </thead>
            <tbody id="resultsBody">
              <tr class="empty-row">
                <td colspan="6">
                  <div class="empty-state">
                    Sin resultados &#8212; inicia el procesamiento
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="log-console">
        <div class="log-header">
          <div class="log-traffic-lights">
            <span class="tl tl-red"></span>
            <span class="tl tl-yellow"></span>
            <span class="tl tl-green"></span>
          </div>
          <span class="log-title">Terminal</span>
          <button class="log-clear" id="btnClearLog">Limpiar</button>
        </div>
        <div class="log-body" id="logBody">
          <div class="log-entry info">
            <span class="log-ts">--:--:--</span>
            <span class="log-msg">Esperando conexion con el servidor&#8230;</span>
          </div>
        </div>
      </div>

    </div>
  </div>

</div>

<footer>
  <span>N-Core Dashboard</span>
  <span class="footer-sep">&#183;</span>
  <span>Version 4.0</span>
  <span class="footer-sep">&#183;</span>
  <span>DAM-2</span>
  <span class="footer-sep">&#183;</span>
  <span>Programacion de Servicios y Procesos</span>
</footer>

<script src="app.js"></script>
</body>
</html>
```
**styles.css**
```css
Ôªø/* 
   N-CORE DASHBOARD v4  Professional UI
   Palette: #393646 ¬∑ #4F4557 ¬∑ #6D5D6E ¬∑ #F4EEE0
    */

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600;700&display=swap');

/*  Reset  */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/*  Variables  */
:root {
  /* Base colors ‚Äî palette #393646 ¬∑ #4F4557 ¬∑ #6D5D6E ¬∑ #F4EEE0 */
  --bg-root:    #27242f;
  --bg-surface: #2e2b38;
  --bg-panel:   #393646;
  --bg-card:    #4F4557;
  --bg-hover:   rgba(109,93,110,.18);
  --bg-active:  rgba(192,176,228,.08);

  /* Borders ‚Äî derived from #6D5D6E (109,93,110) */
  --border:     rgba(109,93,110,.38);
  --border-md:  rgba(109,93,110,.60);
  --border-hi:  rgba(244,238,224,.12);

  /* Text ‚Äî based on #F4EEE0 (244,238,224) */
  --text-primary:   #F4EEE0;
  --text-secondary: rgba(244,238,224,.55);
  --text-muted:     rgba(244,238,224,.30);

  /* Accent colors ‚Äî warm & harmonious con la paleta */
  --indigo:     #c0b0e4;
  --indigo-dim: rgba(192,176,228,.12);
  --indigo-glow:rgba(192,176,228,.22);
  --green:      #96c9a0;
  --green-dim:  rgba(150,201,160,.10);
  --blue:       #a8c4e0;
  --blue-dim:   rgba(168,196,224,.10);
  --orange:     #d4aa72;
  --orange-dim: rgba(212,170,114,.10);
  --purple:     #b897cc;
  --purple-dim: rgba(184,151,204,.10);
  --red:        #d08888;
  --red-dim:    rgba(208,136,136,.10);
  --yellow:     #d8c880;

  /* Sizes */
  --radius:    12px;
  --radius-sm: 8px;
  --radius-xs: 5px;
  --gap:       18px;

  /* Fonts */
  --font-mono: 'JetBrains Mono', 'Cascadia Code', monospace;
  --font-ui:   'Inter', system-ui, sans-serif;

  /* Shadows */
  --shadow-panel: 0 1px 3px rgba(0,0,0,.4), 0 8px 32px rgba(0,0,0,.35), 0 0 0 1px var(--border);
  --shadow-card:  0 1px 2px rgba(0,0,0,.3), 0 4px 16px rgba(0,0,0,.25);
  --shadow-lift:  0 8px 40px rgba(0,0,0,.5);
  --shadow-glow:  0 0 32px var(--indigo-glow);
}

/*  Base  */
html, body {
  min-height: 100%;
  background: var(--bg-root);
  color: var(--text-primary);
  font-family: var(--font-ui);
  font-size: 13px;
  line-height: 1.6;
  overflow-x: hidden;
}

/* Ambient background glow */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(ellipse 80% 50% at 10% -10%, rgba(192,176,228,.06) 0%, transparent 60%),
    radial-gradient(ellipse 60% 40% at 90% 100%, rgba(109,93,110,.08) 0%, transparent 60%),
    radial-gradient(rgba(244,238,224,.018) 1px, transparent 1px);
  background-size: auto, auto, 30px 30px;
  pointer-events: none;
  z-index: 0;
}
body > * { position: relative; z-index: 1; }

/*  Scrollbars  */
::-webkit-scrollbar       { width: 4px; height: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(109,93,110,.5); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: rgba(109,93,110,.75); }

/* 
   HEADER
    */
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 24px;
  height: 58px;
  background: rgba(39,36,47,.94);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  z-index: 200;
  box-shadow: 0 1px 0 var(--border), 0 4px 32px rgba(0,0,0,.4);
}

/* Brand */
.brand {
  display: flex;
  align-items: center;
  gap: 12px;
}

.brand-logo {
  width: 34px;
  height: 34px;
  background: linear-gradient(135deg, #6D5D6E, var(--indigo));
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-primary);
  flex-shrink: 0;
  box-shadow: 0 0 20px rgba(192,176,228,.3), 0 2px 8px rgba(0,0,0,.5);
}
.brand-logo svg { width: 18px; height: 18px; }

.brand-text {
  display: flex;
  flex-direction: column;
  gap: 1px;
  line-height: 1.2;
}
.brand-name {
  font-weight: 800;
  font-size: 15px;
  letter-spacing: -.02em;
  color: var(--text-primary);
}
.brand-sub {
  font-size: 10.5px;
  color: var(--text-muted);
  letter-spacing: .01em;
}

.version-badge {
  background: var(--indigo-dim);
  color: var(--indigo);
  font-size: 10px;
  font-weight: 700;
  padding: 3px 8px;
  border-radius: 20px;
  letter-spacing: .08em;
  text-transform: uppercase;
  border: 1px solid rgba(192,176,228,.2);
}

/* Header right */
.header-right {
  display: flex;
  align-items: center;
  gap: 14px;
}

/* State badge */
.state-badge {
  display: inline-flex;
  align-items: center;
  gap: 7px;
  padding: 5px 13px 5px 10px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: .05em;
  text-transform: uppercase;
  border: 1px solid transparent;
  transition: all .25s;
}
.badge-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: currentColor;
  flex-shrink: 0;
}
.state-badge.idle {
  background: rgba(109,93,110,.2);
  color: var(--text-muted);
  border-color: var(--border);
}
.state-badge.running {
  background: var(--green-dim);
  color: var(--green);
  border-color: rgba(150,201,160,.2);
  animation: badge-pulse 1.5s ease-in-out infinite;
}
.state-badge.stopping {
  background: var(--orange-dim);
  color: var(--orange);
  border-color: rgba(212,170,114,.2);
}

@keyframes badge-pulse {
  0%,100% { opacity: 1; }
  50% { opacity: .6; }
}

/* Connection indicator */
.conn-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: var(--text-secondary);
  padding: 5px 12px;
  background: rgba(109,93,110,.12);
  border: 1px solid var(--border);
  border-radius: 20px;
  transition: border-color .2s;
}
.conn-indicator:hover { border-color: var(--border-md); }

.conn-dot {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: var(--red);
  flex-shrink: 0;
  transition: background .4s;
}
.conn-dot.connected {
  background: var(--green);
  box-shadow: 0 0 10px rgba(150,201,160,.5);
  animation: pulse-conn 2.4s infinite;
}
@keyframes pulse-conn {
  0%,100% { box-shadow: 0 0 0 0 rgba(150,201,160,.5); }
  60%      { box-shadow: 0 0 0 5px rgba(150,201,160,0); }
}

/* 
   LAYOUT
    */
.layout {
  display: grid;
  grid-template-columns: 280px 1fr;
  gap: var(--gap);
  padding: var(--gap);
  max-width: 1760px;
  margin: 0 auto;
}

/* 
   PANEL BASE
    */
.panel {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  box-shadow: var(--shadow-panel);
  transition: border-color .2s, box-shadow .2s;
}
.panel:hover {
  border-color: var(--border-md);
}

.panel-title {
  font-size: 10.5px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .14em;
  color: var(--text-muted);
  margin-bottom: 18px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.panel-icon {
  width: 14px;
  height: 14px;
  opacity: .5;
  flex-shrink: 0;
}
.panel-title-spacer { flex: 1; }

/* 
   SIDEBAR
    */
.sidebar {
  display: flex;
  flex-direction: column;
  gap: var(--gap);
}

/* Sistema info */
.sys-info { display: flex; flex-direction: column; gap: 10px; }

.sys-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12.5px;
}
.sys-key {
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 6px;
}
.sys-key svg { width: 12px; height: 12px; opacity: .45; }
.sys-val {
  font-family: var(--font-mono);
  font-weight: 600;
  font-size: 12px;
  color: var(--text-primary);
}
.sys-val.accent-blue   { color: var(--blue); }
.sys-val.accent-purple { color: var(--purple); }

.sys-divider { height: 1px; background: var(--border); margin: 4px 0; }

.sys-metric .sys-key { font-size: 11.5px; }

/* Mini bars */
.mini-bar-track {
  height: 4px;
  background: rgba(109,93,110,.2);
  border-radius: 4px;
  overflow: hidden;
  margin-top: -2px;
}
.mini-bar-fill {
  height: 100%;
  border-radius: 4px;
  transition: width .7s cubic-bezier(.4,0,.2,1);
}
.mini-bar-fill.blue   { background: linear-gradient(90deg, var(--blue), var(--indigo)); }
.mini-bar-fill.purple { background: linear-gradient(90deg, var(--purple), #c8a0dc); }

/* Control groups */
.control-group { margin-bottom: 18px; }
.control-group:last-of-type { margin-bottom: 0; }

.control-label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10.5px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: .1em;
  margin-bottom: 9px;
}
.control-label svg { width: 11px; height: 11px; }

/* Slider workers */
.worker-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

input[type="range"] {
  flex: 1;
  height: 4px;
  cursor: pointer;
  accent-color: var(--indigo);
  background: rgba(109,93,110,.25);
  border-radius: 4px;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--indigo);
  cursor: pointer;
  box-shadow: 0 0 10px rgba(192,176,228,.4);
  border: 2px solid rgba(244,238,224,.15);
  transition: box-shadow .15s, transform .15s;
}
input[type="range"]::-webkit-slider-thumb:hover {
  box-shadow: 0 0 18px rgba(192,176,228,.6);
  transform: scale(1.15);
}

.worker-val {
  min-width: 32px;
  text-align: center;
  font-family: var(--font-mono);
  font-weight: 700;
  color: var(--indigo);
  font-size: 16px;
  background: var(--indigo-dim);
  border-radius: var(--radius-xs);
  padding: 2px 8px;
  border: 1px solid rgba(192,176,228,.18);
}

/* Select */
select {
  width: 100%;
  background: var(--bg-card);
  color: var(--text-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 9px 32px 9px 12px;
  font-family: var(--font-ui);
  font-size: 12.5px;
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='11' height='7'%3E%3Cpath d='M0.5 1L5.5 6L10.5 1' stroke='rgba(244,238,224,0.3)' stroke-width='1.5' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 11px center;
  transition: border-color .15s, box-shadow .15s;
  outline: none;
}
select:focus {
  border-color: rgba(192,176,228,.45);
  box-shadow: 0 0 0 3px rgba(192,176,228,.07);
}
select option { background: var(--bg-card); }

/* Operation checkboxes */
.op-list { display: flex; flex-direction: column; gap: 6px; }

.op-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 9px 12px;
  border-radius: var(--radius-sm);
  background: var(--bg-card);
  border: 1px solid var(--border);
  cursor: pointer;
  transition: border-color .15s, background .15s;
  user-select: none;
  position: relative;
}
.op-item:hover {
  border-color: var(--border-md);
  background: var(--bg-hover);
}
.op-item:has(input:checked) {
  border-color: rgba(192,176,228,.28);
  background: var(--bg-active);
}

.op-item input[type="checkbox"] { display: none; }

.op-checkmark {
  width: 15px;
  height: 15px;
  border-radius: 4px;
  border: 1.5px solid var(--border-md);
  background: transparent;
  flex-shrink: 0;
  transition: all .15s;
  position: relative;
}
.op-item:has(input:checked) .op-checkmark {
  background: var(--indigo);
  border-color: var(--indigo);
}
.op-item:has(input:checked) .op-checkmark::after {
  content: '';
  position: absolute;
  left: 3px;
  top: 1px;
  width: 5px;
  height: 8px;
  border: 2px solid #fff;
  border-left: none;
  border-top: none;
  transform: rotate(45deg);
}

.op-item .op-name { flex: 1; font-size: 12.5px; font-weight: 500; }

.op-badge {
  font-size: 9px;
  padding: 2px 7px;
  border-radius: 10px;
  font-weight: 700;
  letter-spacing: .05em;
  text-transform: uppercase;
  border: 1px solid transparent;
}
.op-badge.blur     { background: var(--blue-dim);   color: var(--blue);    border-color: rgba(168,196,224,.2); }
.op-badge.grises   { background: rgba(244,238,224,.05); color: var(--text-secondary); border-color: var(--border); }
.op-badge.resize   { background: var(--green-dim);  color: var(--green);   border-color: rgba(150,201,160,.18); }
.op-badge.sharpen  { background: var(--orange-dim); color: var(--orange);  border-color: rgba(212,170,114,.18); }
.op-badge.contorno { background: var(--purple-dim); color: var(--purple);  border-color: rgba(184,151,204,.18); }

/* Buttons */
.btn-group { display: flex; flex-direction: column; gap: 8px; margin-top: 4px; }

.btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  padding: 11px 16px;
  border: 1px solid transparent;
  border-radius: var(--radius-sm);
  font-family: var(--font-ui);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all .18s;
  letter-spacing: .02em;
  position: relative;
  overflow: hidden;
}
.btn svg { width: 14px; height: 14px; flex-shrink: 0; }
.btn:active  { transform: scale(.97); }
.btn:disabled { opacity: .3; cursor: not-allowed; transform: none; }
.btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(to bottom, rgba(244,238,224,.05) 0%, transparent 100%);
  pointer-events: none;
}

.btn-start {
  background: linear-gradient(135deg, #22c55e, #16a34a);
  color: #fff;
  border-color: rgba(34,197,94,.35);
  box-shadow: 0 2px 16px rgba(34,197,94,.25), 0 1px 3px rgba(0,0,0,.3);
}
.btn-start:hover:not(:disabled) {
  box-shadow: 0 4px 24px rgba(34,197,94,.4), 0 1px 3px rgba(0,0,0,.3);
  border-color: rgba(34,197,94,.5);
  transform: translateY(-1px);
}
.btn-start.running {
  background: linear-gradient(135deg, var(--orange), #b88840);
  border-color: rgba(212,170,114,.4);
  box-shadow: 0 2px 16px rgba(212,170,114,.3);
  animation: running-glow 1.8s ease-in-out infinite;
}
@keyframes running-glow {
  0%,100% { box-shadow: 0 2px 16px rgba(212,170,114,.25); }
  50%      { box-shadow: 0 4px 28px rgba(212,170,114,.5); }
}

.btn-stop {
  background: transparent;
  color: var(--red);
  border-color: rgba(208,136,136,.25);
}
.btn-stop:hover:not(:disabled) {
  background: var(--red-dim);
  border-color: rgba(208,136,136,.45);
  box-shadow: 0 0 16px rgba(208,136,136,.15);
}

/* 
   MAIN AREA
    */
.main-area {
  display: flex;
  flex-direction: column;
  gap: var(--gap);
  min-width: 0;
}

/*  Metric Cards  */
.metrics-row {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: var(--gap);
}

.metric-card {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  display: flex;
  align-items: flex-start;
  gap: 16px;
  position: relative;
  overflow: hidden;
  box-shadow: var(--shadow-card);
  transition: border-color .2s, transform .2s, box-shadow .2s;
}
.metric-card::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  border-radius: var(--radius) var(--radius) 0 0;
}
.metric-card::after {
  content: '';
  position: absolute;
  top: -20px; right: -20px;
  width: 80px; height: 80px;
  border-radius: 50%;
  opacity: .06;
}
.metric-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lift);
  border-color: var(--border-md);
}

.metric-card.green::before { background: linear-gradient(90deg, var(--green), transparent); }
.metric-card.green::after  { background: var(--green); }
.metric-card.blue::before  { background: linear-gradient(90deg, var(--blue), transparent); }
.metric-card.blue::after   { background: var(--blue); }
.metric-card.orange::before{ background: linear-gradient(90deg, var(--orange), transparent); }
.metric-card.orange::after { background: var(--orange); }
.metric-card.purple::before{ background: linear-gradient(90deg, var(--purple), transparent); }
.metric-card.purple::after { background: var(--purple); }

.metric-icon {
  width: 38px;
  height: 38px;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  margin-top: 2px;
}
.metric-icon svg { width: 18px; height: 18px; }

.metric-card.green  .metric-icon { background: var(--green-dim);  color: var(--green);  border: 1px solid rgba(150,201,160,.15); }
.metric-card.blue   .metric-icon { background: var(--blue-dim);   color: var(--blue);   border: 1px solid rgba(168,196,224,.15); }
.metric-card.orange .metric-icon { background: var(--orange-dim); color: var(--orange); border: 1px solid rgba(212,170,114,.15); }
.metric-card.purple .metric-icon { background: var(--purple-dim); color: var(--purple); border: 1px solid rgba(184,151,204,.15); }

.metric-body { flex: 1; min-width: 0; }

.m-label {
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .12em;
  color: var(--text-muted);
  margin-bottom: 6px;
}
.m-value {
  font-family: var(--font-mono);
  font-size: 28px;
  font-weight: 700;
  line-height: 1;
  margin-bottom: 5px;
}
.m-sub { font-size: 11px; color: var(--text-secondary); }

.metric-card.green  .m-value { color: var(--green); }
.metric-card.blue   .m-value { color: var(--blue); }
.metric-card.orange .m-value { color: var(--orange); }
.metric-card.purple .m-value { color: var(--purple); }

/*  Progress  */
.progress-counter-badge {
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 600;
  color: var(--text-secondary);
  background: rgba(109,93,110,.15);
  padding: 2px 9px;
  border-radius: 10px;
  border: 1px solid var(--border);
}

.progress-section { display: flex; flex-direction: column; gap: 12px; }

.progress-bar-track {
  height: 8px;
  background: rgba(109,93,110,.25);
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(109,93,110,.15);
  position: relative;
}
.progress-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--indigo), var(--purple), var(--blue));
  background-size: 200% 100%;
  border-radius: 8px;
  width: 0%;
  transition: width .5s cubic-bezier(.4,0,.2,1);
  position: relative;
}
.progress-bar-fill::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
  background-size: 200% 100%;
  animation: shimmer 2.2s linear infinite;
}
@keyframes shimmer {
  0%   { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

.progress-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.progress-label {
  font-size: 12.5px;
  font-weight: 600;
  color: var(--text-primary);
}
.progress-file {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 55%;
  text-align: right;
}
.progress-file::before {
  content: ' ';
  color: var(--indigo);
}

/*  CPU Grid  */
.cpu-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(78px, 1fr));
  gap: 10px;
}
.cpu-placeholder {
  grid-column: 1 / -1;
  text-align: center;
  color: var(--text-muted);
  font-size: 12px;
  padding: 14px 0;
}

.core-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 11px 9px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 7px;
  transition: border-color .3s, box-shadow .3s;
}
.core-label {
  font-size: 9px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: .08em;
}
.core-usage-bar {
  width: 100%;
  height: 46px;
  background: rgba(109,93,110,.2);
  border-radius: 4px;
  overflow: hidden;
  display: flex;
  align-items: flex-end;
}
.core-bar-fill {
  width: 100%;
  transition: height .5s cubic-bezier(.4,0,.2,1);
  border-radius: 4px 4px 0 0;
  position: relative;
}
.core-bar-fill::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: rgba(255,255,255,.35);
  border-radius: 4px;
}
.core-pct {
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 700;
  color: var(--text-primary);
}

.core-bar-fill.low    { background: linear-gradient(to top, var(--green), #86efac); }
.core-bar-fill.medium { background: linear-gradient(to top, var(--indigo), #a5b4fc); }
.core-bar-fill.high   { background: linear-gradient(to top, var(--orange), #fed7aa); }
.core-bar-fill.max    { background: linear-gradient(to top, var(--red), #fca5a5); }

.core-card:has(.low)    { border-color: rgba(150,201,160,.22);  box-shadow: 0 0 10px rgba(150,201,160,.05); }
.core-card:has(.medium) { border-color: rgba(192,176,228,.22);  box-shadow: 0 0 10px rgba(192,176,228,.05); }
.core-card:has(.high)   { border-color: rgba(212,170,114,.25);  box-shadow: 0 0 10px rgba(212,170,114,.06); }
.core-card:has(.max)    { border-color: rgba(208,136,136,.25);  box-shadow: 0 0 10px rgba(208,136,136,.08); }

/*  Bottom area  */
.bottom-area {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--gap);
}

/* Results table */
.panel-table { padding-bottom: 0; }

.results-scroll {
  max-height: 300px;
  overflow-y: auto;
  margin: 0 -20px;
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,.08) transparent;
}

.results-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}
.results-table thead th {
  text-align: left;
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 9.5px;
  text-transform: uppercase;
  letter-spacing: .12em;
  font-weight: 700;
  white-space: nowrap;
  background: rgba(109,93,110,.18);
  position: sticky;
  top: 0;
  z-index: 1;
}
.results-table tbody tr {
  border-bottom: 1px solid rgba(109,93,110,.25);
  transition: background .1s;
}
.results-table tbody tr:hover { background: var(--bg-hover); }
.results-table tbody tr:last-child { border-bottom: none; }
.results-table td {
  padding: 9px 16px;
  vertical-align: middle;
}
.results-table td:first-child {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--blue);
  max-width: 140px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.empty-state {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 28px;
  color: var(--text-muted);
  font-size: 12px;
}
.empty-state svg { width: 18px; height: 18px; opacity: .4; }

/* Tags */
.tag {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 8px;
  font-size: 9.5px;
  font-weight: 600;
  margin: 1px 2px;
  letter-spacing: .03em;
  border: 1px solid transparent;
}
.tag.blur     { background: var(--blue-dim);    color: var(--blue);    border-color: rgba(168,196,224,.2); }
.tag.grises   { background: rgba(244,238,224,.05); color: var(--text-secondary); border-color: var(--border); }
.tag.resize   { background: var(--green-dim);   color: var(--green);   border-color: rgba(150,201,160,.18); }
.tag.sharpen  { background: var(--orange-dim);  color: var(--orange);  border-color: rgba(212,170,114,.18); }
.tag.contorno { background: var(--purple-dim);  color: var(--purple);  border-color: rgba(184,151,204,.18); }

/* Log Console */
.log-console {
  background: #2c2838;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: var(--shadow-panel);
}

.log-header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 16px;
  background: rgba(109,93,110,.22);
  border-bottom: 1px solid var(--border);
}
.log-traffic-lights {
  display: flex;
  gap: 6px;
  align-items: center;
}
.tl {
  width: 11px;
  height: 11px;
  border-radius: 50%;
}
.tl-red    { background: #ff5f57; }
.tl-yellow { background: #ffbd2e; }
.tl-green  { background: #28c840; }

.log-title {
  font-size: 10.5px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .1em;
  color: var(--text-secondary);
  flex: 1;
}
.log-clear {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 10.5px;
  color: var(--text-muted);
  background: none;
  border: 1px solid var(--border);
  border-radius: var(--radius-xs);
  padding: 3px 9px;
  cursor: pointer;
  font-family: var(--font-ui);
  transition: all .15s;
}
.log-clear svg { width: 10px; height: 10px; }
.log-clear:hover { color: var(--text-primary); border-color: var(--border-md); background: var(--bg-hover); }

.log-body {
  flex: 1;
  padding: 12px 16px;
  overflow-y: auto;
  height: 300px;
  font-family: var(--font-mono);
  font-size: 11.5px;
  line-height: 1.8;
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,.08) transparent;
}

.log-entry {
  display: flex;
  gap: 12px;
  padding: 1px 0;
}
.log-entry::before {
  content: '';
  color: rgba(255,255,255,.15);
  font-size: 14px;
  line-height: 1.8;
  flex-shrink: 0;
}
.log-entry.success::before { color: var(--green); }
.log-entry.warning::before { color: var(--yellow); }
.log-entry.error::before   { color: var(--red); }

.log-ts  { color: var(--text-muted); white-space: nowrap; flex-shrink: 0; }
.log-msg { word-break: break-all; }
.log-entry.info    .log-msg { color: rgba(244,238,224,.4); }
.log-entry.success .log-msg { color: var(--green); }
.log-entry.warning .log-msg { color: var(--yellow); }
.log-entry.error   .log-msg { color: var(--red); }

/*  Footer  */
footer {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 16px;
  font-size: 11px;
  color: var(--text-muted);
  border-top: 1px solid var(--border);
  letter-spacing: .06em;
  text-transform: uppercase;
}
.footer-sep { opacity: .25; }

/* 
   RESPONSIVE
    */
@media (max-width: 1150px) {
  .layout      { grid-template-columns: 1fr; }
  .metrics-row { grid-template-columns: repeat(2, 1fr); }
  .bottom-area { grid-template-columns: 1fr; }
}
@media (max-width: 640px) {
  .metrics-row { grid-template-columns: 1fr; }
  .brand-sub   { display: none; }
  .layout      { padding: 12px; gap: 12px; }
}
```
## imagenes_entrada
## imagenes_salida